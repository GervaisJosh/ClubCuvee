{"version":3,"mappings":"+CAIA,MAAMA,EAAkB,8GAClBC,EAAgBC,EAAWF,CAAe,EAEnCG,EAAgB,CAC3B,MAAM,sBAAsBC,EAA4C,CAClE,IAEF,MAAMC,EAAY,CAChB,GAAGD,EACH,SAAU,CACR,GAAIA,EAAK,UAAY,CAAC,EACtB,KAAMA,EAAK,MAAQ,wBAEvB,EAEME,EAAW,MAAM,MAAM,+BAAgC,CAC3D,OAAQ,OACR,QAAS,CAAE,eAAgB,kBAAmB,EAC9C,KAAM,KAAK,UAAUD,CAAS,EAC/B,EAEKE,EAAS,MAAMD,EAAS,KAAK,EAC/B,IAACA,EAAS,GAAI,MAAM,IAAI,MAAMC,EAAO,OAAS,mCAAmC,EACrF,OAAOA,EAAO,SACPC,EAAY,CACX,oBAAM,mCAAoCA,CAAK,EACjDA,CAAA,CAEV,EAEA,MAAM,mBAAmBC,EAAkC,CACrD,IACF,MAAMC,EAAS,MAAMT,EACrB,GAAI,CAACS,EAAc,UAAI,MAAM,uBAAuB,EAE9C,MAAE,MAAAF,GAAU,MAAME,EAAO,mBAAmB,CAAE,UAAAD,EAAW,EAC/D,GAAID,EAAa,UAAI,MAAMA,EAAM,SAAW,6BAA6B,QAClEA,EAAY,CACX,oBAAM,iCAAkCA,CAAK,EAC/CA,CAAA,CAEV,EAEA,MAAM,qBAAqBC,EAAqC,CAC1D,IAACA,EAAkB,SAEnB,IAOK,eACAD,EAAO,CACN,qBAAM,mCAAoCA,CAAK,EAChD,GAEX,EAGA,MAAM,cAAcC,EAAmBL,EAKrB,CACZ,IACF,KAAM,CAAE,MAAAI,CAAA,EAAU,MAAM,MAAM,uBAAwB,CACpD,OAAQ,OACR,QAAS,CAAE,eAAgB,kBAAmB,EAC9C,KAAM,KAAK,UAAU,CACnB,kBAAmBC,EACnB,KAAML,EAAK,KACX,OAAQA,EAAK,OACb,cAAeA,EAAK,aACpB,eAAgBA,EAAK,aACtB,GACF,EAED,GAAII,EAAa,MAAAA,QACVA,EAAO,CACN,cAAM,2BAA4BA,CAAK,EAGnD,EAGA,MAAM,mBAQH,CACG,IAEF,KAAM,CAAE,WAAAG,EAAY,WAAAC,GAAe,MAAAC,EAAA,2BAAAF,EAAA,WAAAC,CAAA,OAAM,QAAO,+BAAmB,oBAAAD,EAAA,WAAAC,CAAA,OAK5D,OAJQ,MAAMD,EAAW,qBAAsB,CACpD,OAAQ,MACT,QAGMH,EAAY,CAIf,OAHI,cAAM,0BAA2BA,CAAK,EAG1CA,EAAM,OAAS,WACV,CACL,OAAQ,QACR,MAAOA,EAAM,QACb,KAAMA,EAAM,KACZ,QAASA,EAAM,IACjB,EAIK,CACL,OAAQ,QACR,MAAOA,EAAM,SAAW,uCAC1B,EACF,CAEJ","names":["stripePublicKey","stripePromise","loadStripe","stripeService","data","finalData","response","result","error","sessionId","stripe","apiRequest","isApiError","__vitePreload"],"ignoreList":[],"sources":["../../src/services/stripeService.ts"],"sourcesContent":["import { loadStripe } from '@stripe/stripe-js';\r\nimport type { CheckoutSessionData } from '../types';\r\n\r\n// Initialize Stripe with the public key\r\nconst stripePublicKey = import.meta.env.VITE_STRIPE_PUBLIC_KEY;\r\nconst stripePromise = loadStripe(stripePublicKey);\r\n\r\nexport const stripeService = {\r\n  async createCheckoutSession(data: CheckoutSessionData): Promise<string> {\r\n    try {\r\n      // Make sure to include metadata about the type of checkout\r\n      const finalData = {\r\n        ...data,\r\n        metadata: {\r\n          ...(data.metadata || {}),\r\n          type: data.type || 'customer_subscription'\r\n        }\r\n      };\r\n      \r\n      const response = await fetch('/api/create-checkout-session', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(finalData),\r\n      });\r\n      \r\n      const result = await response.json();\r\n      if (!response.ok) throw new Error(result.error || 'Failed to create checkout session');\r\n      return result.id;\r\n    } catch (error: any) {\r\n      console.error('Error creating checkout session:', error);\r\n      throw error;\r\n    }\r\n  },\r\n  \r\n  async redirectToCheckout(sessionId: string): Promise<void> {\r\n    try {\r\n      const stripe = await stripePromise;\r\n      if (!stripe) throw new Error('Failed to load Stripe');\r\n      \r\n      const { error } = await stripe.redirectToCheckout({ sessionId });\r\n      if (error) throw new Error(error.message || 'Redirect to checkout failed');\r\n    } catch (error: any) {\r\n      console.error('Error redirecting to checkout:', error);\r\n      throw error;\r\n    }\r\n  },\r\n  \r\n  async verifyPaymentSession(sessionId: string): Promise<boolean> {\r\n    if (!sessionId) return false;\r\n    \r\n    try {\r\n      // You can add additional verification here if needed\r\n      // For example, a call to your backend to verify the session\r\n      // is valid and belongs to the expected customer\r\n      \r\n      // For simplicity, we're just checking the session ID exists\r\n      // In production, you would validate this against Stripe\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error verifying payment session:', error);\r\n      return false;\r\n    }\r\n  },\r\n  \r\n  // Optional helper if you want to track payments in your own DB\r\n  async recordPayment(sessionId: string, data: {\r\n    tier: string;\r\n    amount: number;\r\n    restaurantId?: string;\r\n    customerEmail?: string;\r\n  }): Promise<void> {\r\n    try {\r\n      const { error } = await fetch('/api/payments/record', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({\r\n          stripe_session_id: sessionId,\r\n          tier: data.tier,\r\n          amount: data.amount,\r\n          restaurant_id: data.restaurantId,\r\n          customer_email: data.customerEmail\r\n        }),\r\n      });\r\n      \r\n      if (error) throw error;\r\n    } catch (error) {\r\n      console.error('Error recording payment:', error);\r\n      // Don't throw, as this is non-critical\r\n    }\r\n  },\r\n  \r\n  // Verify Stripe configuration\r\n  async verifyStripeSetup(): Promise<{\r\n    status: string;\r\n    livemode?: boolean;\r\n    config?: Record<string, string>;\r\n    balance?: any;\r\n    error?: string;\r\n    type?: string;\r\n    details?: any;\r\n  }> {\r\n    try {\r\n      // Use our centralized API request handler\r\n      const { apiRequest, isApiError } = await import('./apiErrorHandler');\r\n      const result = await apiRequest('/api/verify-stripe', {\r\n        method: 'GET'\r\n      });\r\n      \r\n      return result;\r\n    } catch (error: any) {\r\n      console.error('Error verifying Stripe:', error);\r\n      \r\n      // Format the error consistently\r\n      if (error.name === 'ApiError') {\r\n        return {\r\n          status: 'error',\r\n          error: error.message,\r\n          type: error.type,\r\n          details: error.data\r\n        };\r\n      }\r\n      \r\n      // Fallback for other types of errors\r\n      return {\r\n        status: 'error',\r\n        error: error.message || 'Failed to verify Stripe configuration'\r\n      };\r\n    }\r\n  }\r\n};\r\n"],"file":"assets/stripeService-s5a6paZ4.js"}