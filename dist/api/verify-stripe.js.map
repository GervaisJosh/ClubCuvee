{
  "version": 3,
  "sources": ["../../api/verify-stripe.ts"],
  "sourcesContent": ["import type { VercelRequest, VercelResponse } from '@vercel/node';\r\nimport Stripe from 'stripe';\r\nimport { formatApiError, sendApiError } from './utils/errorHandler';\r\n\r\n/**\r\n * API endpoint for verifying Stripe configuration\r\n * Tests connectivity to Stripe API and verifies environment variables\r\n * Production-ready with comprehensive error handling\r\n */\r\nexport default async function handler(req: VercelRequest, res: VercelResponse) {\r\n  // Set content type to JSON for ALL responses\r\n  res.setHeader('Content-Type', 'application/json');\r\n  \r\n  try {\r\n    // Set CORS headers\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\r\n    \r\n    // Handle preflight OPTIONS requests\r\n    if (req.method === 'OPTIONS') {\r\n      return res.status(200).send(JSON.stringify({ status: 'success' }));\r\n    }\r\n    \r\n    // Ensure method is GET\r\n    if (req.method !== 'GET') {\r\n      return res.status(405).send(JSON.stringify({ \r\n        status: 'error',\r\n        error: 'Method not allowed',\r\n        allowed_methods: ['GET', 'OPTIONS']\r\n      }));\r\n    }\r\n    \r\n    // Validate environment variables\r\n    const stripeSecretKey = process.env.STRIPE_SECRET_KEY;\r\n    \r\n    if (!stripeSecretKey) {\r\n      return res.status(500).send(JSON.stringify({\r\n        status: 'error',\r\n        error: 'Missing Stripe configuration',\r\n        message: 'STRIPE_SECRET_KEY is not set in environment variables',\r\n        config: {\r\n          STRIPE_SECRET_KEY: 'missing',\r\n          STRIPE_WEBHOOK_SECRET: !!process.env.STRIPE_WEBHOOK_SECRET ? 'configured' : 'missing',\r\n          STRIPE_PUBLIC_KEY: !!(process.env.VITE_STRIPE_PUBLIC_KEY || process.env.STRIPE_PUBLIC_KEY) ? 'configured' : 'missing',\r\n        }\r\n      }));\r\n    }\r\n    \r\n    // Initialize Stripe client with test mode configuration\r\n    let stripe;\r\n    try {\r\n      stripe = new Stripe(stripeSecretKey, {\r\n        apiVersion: '2023-10-16',\r\n        maxNetworkRetries: 3,\r\n      });\r\n    } catch (initError: any) {\r\n      console.error('Failed to initialize Stripe client:', initError);\r\n      return res.status(500).send(JSON.stringify({\r\n        status: 'error',\r\n        error: 'Stripe initialization failed',\r\n        message: initError.message || 'Could not initialize Stripe client'\r\n      }));\r\n    }\r\n    \r\n    // Verify Stripe connection by retrieving account balance\r\n    let balance;\r\n    try {\r\n      balance = await stripe.balance.retrieve();\r\n    } catch (apiError: any) {\r\n      console.error('Failed to retrieve Stripe balance:', apiError);\r\n      \r\n      const statusCode = apiError.type === 'StripeAuthenticationError' ? 401 :\r\n                         apiError.type === 'StripeConnectionError' ? 503 :\r\n                         apiError.type === 'StripeAPIError' ? 502 : 500;\r\n      \r\n      return res.status(statusCode).send(JSON.stringify({\r\n        status: 'error',\r\n        error: 'Stripe API verification failed',\r\n        message: apiError.message || 'Could not connect to Stripe API',\r\n        type: apiError.type || 'unknown'\r\n      }));\r\n    }\r\n    \r\n    // Return success response with configuration status\r\n    return res.status(200).send(JSON.stringify({\r\n      status: 'success',\r\n      message: 'Stripe API connection successful',\r\n      livemode: balance.livemode,\r\n      config: {\r\n        STRIPE_SECRET_KEY: 'configured',\r\n        STRIPE_WEBHOOK_SECRET: !!process.env.STRIPE_WEBHOOK_SECRET ? 'configured' : 'missing',\r\n        STRIPE_PUBLIC_KEY: !!(process.env.VITE_STRIPE_PUBLIC_KEY || process.env.STRIPE_PUBLIC_KEY) ? 'configured' : 'missing',\r\n      },\r\n      balance: {\r\n        available: balance.available.map(b => ({ \r\n          amount: (b.amount / 100).toFixed(2),\r\n          currency: b.currency \r\n        })),\r\n        pending: balance.pending.map(b => ({ \r\n          amount: (b.amount / 100).toFixed(2),\r\n          currency: b.currency \r\n        })),\r\n      }\r\n    }));\r\n  } catch (error: any) {\r\n    // Log error for server-side debugging\r\n    console.error('Stripe verification error:', error);\r\n    \r\n    // Make sure we haven't already sent a response\r\n    if (res.headersSent) {\r\n      console.error('Cannot send error response - headers already sent');\r\n      return;\r\n    }\r\n    \r\n    // Always ensure Content-Type is set\r\n    res.setHeader('Content-Type', 'application/json');\r\n    \r\n    // Determine appropriate status code based on error type\r\n    let statusCode = 500;\r\n    if (error.type === 'StripeAuthenticationError') {\r\n      statusCode = 401;\r\n    } else if (error.type === 'StripeConnectionError') {\r\n      statusCode = 503;\r\n    } else if (error.type === 'StripeAPIError') {\r\n      statusCode = 502;\r\n    }\r\n    \r\n    // Always return a properly formatted JSON error response\r\n    return res.status(statusCode).send(JSON.stringify({\r\n      status: 'error',\r\n      error: error.message || 'Internal server error',\r\n      type: error.type || 'unknown',\r\n      details: process.env.NODE_ENV === 'development' ? {\r\n        message: error.message,\r\n        code: error.code,\r\n        type: error.type,\r\n        name: error.name,\r\n      } : undefined\r\n    }));\r\n  }\r\n}"],
  "mappings": "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",
  "names": ["Stripe"]
}
