{
  "version": 3,
  "sources": ["checkoutHandler.ts", "../utils/stripeClient.ts", "../../lib/supabaseAdmin.ts", "../utils/validation.ts"],
  "sourcesContent": ["import { stripe } from '../utils/stripeClient';\r\nimport { supabaseAdmin } from '@/lib/supabaseAdmin';\r\nimport { validateRequest } from '../utils/validation';\r\nimport type { VercelRequest, VercelResponse } from '@vercel/node';\r\n\r\n/**\r\n * Helper function to send JSON response with proper error handling\r\n */\r\nfunction sendJsonResponse(res: VercelResponse, status: number, data: any) {\r\n  try {\r\n    if (!res.headersSent) {\r\n      res.setHeader('Content-Type', 'application/json');\r\n    }\r\n    return res.status(status).json(data);\r\n  } catch (error) {\r\n    console.error('Error sending JSON response:', error);\r\n    if (!res.headersSent) {\r\n      res.setHeader('Content-Type', 'application/json');\r\n      return res.status(500).json({\r\n        status: 'error',\r\n        error: 'Failed to send response',\r\n        message: 'Internal server error'\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create a Stripe checkout session for subscription payments\r\n */\r\nexport async function createCheckoutSession(req: VercelRequest, res: VercelResponse) {\r\n  // Set CORS headers for all responses\r\n  res.setHeader('Access-Control-Allow-Origin', '*');\r\n  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');\r\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\r\n  res.setHeader('Content-Type', 'application/json');\r\n\r\n  try {\r\n    // Handle preflight OPTIONS requests\r\n    if (req.method === 'OPTIONS') {\r\n      return sendJsonResponse(res, 200, { status: 'success' });\r\n    }\r\n\r\n    // Ensure method is POST\r\n    if (req.method !== 'POST') {\r\n      return sendJsonResponse(res, 405, {\r\n        status: 'error',\r\n        error: 'Method not allowed',\r\n        message: 'Only POST requests are allowed',\r\n        allowed_methods: ['POST', 'OPTIONS']\r\n      });\r\n    }\r\n\r\n    const {\r\n      tierId,         // ID of membership_tiers row\r\n      priceId,        // Optional: Direct Stripe price ID\r\n      customerId,     // ID from your \"customers\" table\r\n      customerEmail,  // email for the checkout session\r\n      restaurantId,   // ID of the restaurant\r\n      successUrl,     // Redirect URL on success\r\n      cancelUrl,      // Redirect URL on cancel\r\n      createPrice,    // Whether to create a new price (rare)\r\n      tierData,       // Data for creating a new price (rare)\r\n      metadata,       // Additional metadata for the session\r\n    } = req.body;\r\n    \r\n    // Validation - either tierId or priceId is required\r\n    const validation = validateRequest(\r\n      req.body,\r\n      ['customerId', 'customerEmail', 'restaurantId', 'successUrl', 'cancelUrl']\r\n    );\r\n    \r\n    if (!validation.isValid) {\r\n      return sendJsonResponse(res, 400, {\r\n        status: 'error',\r\n        error: 'Validation failed',\r\n        details: validation.errors,\r\n      });\r\n    }\r\n    \r\n    if (!tierId && !priceId && !createPrice) {\r\n      return sendJsonResponse(res, 400, {\r\n        status: 'error',\r\n        error: 'Invalid request',\r\n        message: 'Either tierId, priceId, or createPrice must be provided'\r\n      });\r\n    }\r\n    \r\n    // If no direct priceId provided, fetch from tier\r\n    let finalPriceId: string;\r\n    let createdPrice = false;\r\n    \r\n    if (priceId) {\r\n      // Direct price ID provided\r\n      finalPriceId = priceId;\r\n    } else if (createPrice && tierData) {\r\n      // Rare case: Create a new price on-the-fly \r\n      // (mainly for testing or reconnecting scenarios)\r\n      try {\r\n        // Create a temporary product\r\n        const product = await stripe.products.create({\r\n          name: tierData.name || 'Membership',\r\n          description: tierData.description || 'Custom membership tier',\r\n          metadata: {\r\n            restaurant_id: restaurantId,\r\n            customer_id: customerId,\r\n            temporary: 'true'\r\n          }\r\n        });\r\n        \r\n        // Create a price for the product\r\n        const price = await stripe.prices.create({\r\n          product: product.id,\r\n          unit_amount: Math.round(parseFloat(tierData.price as string) * 100),\r\n          currency: 'usd',\r\n          recurring: { interval: 'month' },\r\n          metadata: {\r\n            restaurant_id: restaurantId,\r\n            customer_id: customerId,\r\n            temporary: 'true'\r\n          }\r\n        });\r\n        \r\n        finalPriceId = price.id;\r\n        createdPrice = true;\r\n      } catch (err: any) {\r\n        console.error('Error creating price:', err);\r\n        return sendJsonResponse(res, 500, {\r\n          status: 'error',\r\n          error: 'Failed to create price',\r\n          message: err.message || 'Could not create Stripe price'\r\n        });\r\n      }\r\n    } else if (tierId) {\r\n      // Normal case: Get price ID from tier\r\n      const { data: tier, error: tierError } = await supabaseAdmin\r\n        .from('membership_tiers')\r\n        .select('stripe_price_id')\r\n        .eq('id', tierId)\r\n        .eq('restaurant_id', restaurantId) // Security check\r\n        .single();\r\n\r\n      if (tierError || !tier) {\r\n        return sendJsonResponse(res, 404, {\r\n          status: 'error',\r\n          error: 'Tier not found',\r\n          message: tierError?.message || 'Could not find membership tier'\r\n        });\r\n      }\r\n      \r\n      if (!tier.stripe_price_id) {\r\n        return sendJsonResponse(res, 400, {\r\n          status: 'error',\r\n          error: 'Invalid tier configuration',\r\n          message: 'This membership tier is not properly configured for payments'\r\n        });\r\n      }\r\n      \r\n      finalPriceId = tier.stripe_price_id;\r\n    } else {\r\n      return sendJsonResponse(res, 400, {\r\n        status: 'error',\r\n        error: 'Invalid request configuration',\r\n        message: 'Could not determine price ID'\r\n      });\r\n    }\r\n    \r\n    // Create the checkout session\r\n    const sessionMetadata = {\r\n      restaurant_id: restaurantId,\r\n      customer_id: customerId,\r\n      tier_id: tierId || 'custom',\r\n      created_price: createdPrice ? 'true' : 'false',\r\n      ...(metadata || {}) // Spread any additional metadata from the request\r\n    };\r\n\r\n    const session = await stripe.checkout.sessions.create({\r\n      payment_method_types: ['card'],\r\n      line_items: [\r\n        {\r\n          price: finalPriceId,\r\n          quantity: 1\r\n        }\r\n      ],\r\n      mode: 'subscription',\r\n      success_url: successUrl,\r\n      cancel_url: cancelUrl,\r\n      customer_email: customerEmail,\r\n      metadata: sessionMetadata,\r\n      subscription_data: {\r\n        metadata: {\r\n          restaurant_id: restaurantId,\r\n          customer_id: customerId,\r\n          tier_id: tierId || 'custom',\r\n          ...(metadata || {}) // Also add metadata to subscription\r\n        }\r\n      }\r\n    });\r\n    \r\n    return sendJsonResponse(res, 200, {\r\n      status: 'success',\r\n      id: session.id,\r\n      url: session.url\r\n    });\r\n  } catch (error: any) {\r\n    console.error('Error creating checkout session:', error);\r\n    return sendJsonResponse(res, 500, {\r\n      status: 'error',\r\n      error: 'Internal server error',\r\n      message: error.message || 'Failed to create checkout session'\r\n    });\r\n  }\r\n}\r\n\r\nexport default async function handler(req: VercelRequest, res: VercelResponse) {\r\n  if (req.method === 'POST') {\r\n    return createCheckoutSession(req, res);\r\n  } else {\r\n    return sendJsonResponse(res, 405, {\r\n      status: 'error',\r\n      error: 'Method not allowed',\r\n      message: 'Only POST requests are allowed',\r\n      allowed_methods: ['POST', 'OPTIONS']\r\n    });\r\n  }\r\n}\r\n", "import Stripe from 'stripe';\r\nimport { handleStripeError } from '@/lib/utils/errorHandler';\r\n\r\nconst stripeSecretKey = process.env.STRIPE_SECRET_KEY;\r\nif (!stripeSecretKey) {\r\n  console.error('STRIPE_SECRET_KEY is not configured in environment variables');\r\n}\r\n\r\nexport const stripe = new Stripe(stripeSecretKey || 'invalid_key', {\r\n  apiVersion: '2025-02-24.acacia',\r\n  maxNetworkRetries: 3,\r\n  typescript: true,\r\n  appInfo: {\r\n    name: 'Club Cuvee',\r\n    version: '1.0.0'\r\n  }\r\n});\r\n\r\n// Wrapper for Stripe API calls with error handling\r\nexport const stripeApi = {\r\n  createCheckoutSession: async (data: Stripe.Checkout.SessionCreateParams) => {\r\n    try {\r\n      const idempotencyKey = crypto.randomUUID();\r\n      return await stripe.checkout.sessions.create(data, {\r\n        idempotencyKey\r\n      });\r\n    } catch (error) {\r\n      throw handleStripeError(error);\r\n    }\r\n  },\r\n\r\n  createCustomer: async (data: Stripe.CustomerCreateParams) => {\r\n    try {\r\n      const idempotencyKey = crypto.randomUUID();\r\n      return await stripe.customers.create(data, {\r\n        idempotencyKey\r\n      });\r\n    } catch (error) {\r\n      throw handleStripeError(error);\r\n    }\r\n  },\r\n\r\n  createSubscription: async (data: Stripe.SubscriptionCreateParams) => {\r\n    try {\r\n      const idempotencyKey = crypto.randomUUID();\r\n      return await stripe.subscriptions.create(data, {\r\n        idempotencyKey\r\n      });\r\n    } catch (error) {\r\n      throw handleStripeError(error);\r\n    }\r\n  },\r\n\r\n  constructEvent: async (payload: string | Buffer, signature: string, secret: string) => {\r\n    try {\r\n      return stripe.webhooks.constructEvent(payload, signature, secret);\r\n    } catch (error) {\r\n      throw handleStripeError(error);\r\n    }\r\n  }\r\n};", "import { createClient } from '@supabase/supabase-js';\r\n\r\n// Initialize Supabase with service role key for admin operations\r\nexport const supabaseAdmin = createClient(\r\n  process.env.SUPABASE_URL as string,\r\n  process.env.SUPABASE_SERVICE_ROLE_KEY as string,\r\n  {\r\n    auth: {\r\n      autoRefreshToken: false,\r\n      persistSession: false\r\n    }\r\n  }\r\n); ", "// API request validation utilities\r\n\r\nexport interface ValidationError {\r\n  field: string;\r\n  message: string;\r\n}\r\n\r\nexport function validateRequired(\r\n  data: Record<string, any>,\r\n  requiredFields: string[]\r\n): ValidationError[] {\r\n  const errors: ValidationError[] = [];\r\n  \r\n  for (const field of requiredFields) {\r\n    const value = data[field];\r\n    if (value === undefined || value === null || value === '') {\r\n      errors.push({\r\n        field,\r\n        message: `${field} is required`,\r\n      });\r\n    }\r\n  }\r\n  \r\n  return errors;\r\n}\r\n\r\nexport function validateEmail(email: string): boolean {\r\n  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\r\n  return emailRegex.test(email);\r\n}\r\n\r\nexport function validatePrice(price: string | number): boolean {\r\n  if (typeof price === 'number') {\r\n    return price > 0;\r\n  }\r\n  const priceNum = parseFloat(price);\r\n  return !isNaN(priceNum) && priceNum > 0;\r\n}\r\n\r\nexport function validateRequest(\r\n  data: Record<string, any>,\r\n  requiredFields: string[],\r\n  customValidators?: {\r\n    [field: string]: (value: any) => ValidationError | null;\r\n  }\r\n): { isValid: boolean; errors: ValidationError[] } {\r\n  const errors: ValidationError[] = validateRequired(data, requiredFields);\r\n  \r\n  // Run custom validators if provided\r\n  if (customValidators) {\r\n    for (const [field, validator] of Object.entries(customValidators)) {\r\n      if (data[field] !== undefined && data[field] !== null) {\r\n        const validationResult = validator(data[field]);\r\n        if (validationResult) {\r\n          errors.push(validationResult);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors,\r\n  };\r\n}\r\n"],
  "mappings": "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",
  "names": ["Stripe"]
}
