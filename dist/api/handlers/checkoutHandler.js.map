{
  "version": 3,
  "sources": ["checkoutHandler.ts", "../utils/stripeClient.ts", "../../lib/supabaseAdmin.ts", "../utils/validation.ts"],
  "sourcesContent": ["import { stripe } from '../utils/stripeClient';\r\nimport { supabaseAdmin } from '@/lib/supabaseAdmin';\r\nimport { validateRequest } from '../utils/validation';\r\nimport type { VercelRequest, VercelResponse } from '@vercel/node';\r\n\r\n/**\r\n * Create a Stripe checkout session for subscription payments\r\n */\r\nexport async function createCheckoutSession(req: VercelRequest, res: VercelResponse) {\r\n  try {\r\n    const {\r\n      tierId,         // ID of membership_tiers row\r\n      priceId,        // Optional: Direct Stripe price ID\r\n      customerId,     // ID from your \"customers\" table\r\n      customerEmail,  // email for the checkout session\r\n      restaurantId,   // ID of the restaurant\r\n      successUrl,     // Redirect URL on success\r\n      cancelUrl,      // Redirect URL on cancel\r\n      createPrice,    // Whether to create a new price (rare)\r\n      tierData,       // Data for creating a new price (rare)\r\n      metadata,       // Additional metadata for the session\r\n    } = req.body;\r\n    \r\n    // Validation - either tierId or priceId is required\r\n    const validation = validateRequest(\r\n      req.body,\r\n      ['customerId', 'customerEmail', 'restaurantId', 'successUrl', 'cancelUrl']\r\n    );\r\n    \r\n    if (!validation.isValid) {\r\n      return res.status(400).json({\r\n        error: 'Validation failed',\r\n        details: validation.errors,\r\n      });\r\n    }\r\n    \r\n    if (!tierId && !priceId && !createPrice) {\r\n      return res.status(400).json({\r\n        error: 'Either tierId, priceId, or createPrice must be provided'\r\n      });\r\n    }\r\n    \r\n    // If no direct priceId provided, fetch from tier\r\n    let finalPriceId: string;\r\n    let createdPrice = false;\r\n    \r\n    if (priceId) {\r\n      // Direct price ID provided\r\n      finalPriceId = priceId;\r\n    } else if (createPrice && tierData) {\r\n      // Rare case: Create a new price on-the-fly \r\n      // (mainly for testing or reconnecting scenarios)\r\n      try {\r\n        // Create a temporary product\r\n        const product = await stripe.products.create({\r\n          name: tierData.name || 'Membership',\r\n          description: tierData.description || 'Custom membership tier',\r\n          metadata: {\r\n            restaurant_id: restaurantId,\r\n            customer_id: customerId,\r\n            temporary: 'true'\r\n          }\r\n        });\r\n        \r\n        // Create a price for the product\r\n        const price = await stripe.prices.create({\r\n          product: product.id,\r\n          unit_amount: Math.round(parseFloat(tierData.price as string) * 100),\r\n          currency: 'usd',\r\n          recurring: { interval: 'month' },\r\n          metadata: {\r\n            restaurant_id: restaurantId,\r\n            customer_id: customerId,\r\n            temporary: 'true'\r\n          }\r\n        });\r\n        \r\n        finalPriceId = price.id;\r\n        createdPrice = true;\r\n      } catch (err) {\r\n        console.error('Error creating price:', err);\r\n        return res.status(500).json({\r\n          error: 'Failed to create price'\r\n        });\r\n      }\r\n    } else if (tierId) {\r\n      // Normal case: Get price ID from tier\r\n      const { data: tier, error: tierError } = await supabaseAdmin\r\n        .from('membership_tiers')\r\n        .select('stripe_price_id')\r\n        .eq('id', tierId)\r\n        .eq('restaurant_id', restaurantId) // Security check\r\n        .single();\r\n\r\n      if (tierError || !tier) {\r\n        return res.status(404).json({\r\n          error: tierError?.message || 'Tier not found'\r\n        });\r\n      }\r\n      \r\n      if (!tier.stripe_price_id) {\r\n        return res.status(400).json({\r\n          error: 'This membership tier is not properly configured for payments'\r\n        });\r\n      }\r\n      \r\n      finalPriceId = tier.stripe_price_id;\r\n    } else {\r\n      return res.status(400).json({\r\n        error: 'Invalid request configuration'\r\n      });\r\n    }\r\n    \r\n    // Create the checkout session\r\n    const sessionMetadata = {\r\n      restaurant_id: restaurantId,\r\n      customer_id: customerId,\r\n      tier_id: tierId || 'custom',\r\n      created_price: createdPrice ? 'true' : 'false',\r\n      ...(metadata || {}) // Spread any additional metadata from the request\r\n    };\r\n\r\n    const session = await stripe.checkout.sessions.create({\r\n      payment_method_types: ['card'],\r\n      line_items: [\r\n        {\r\n          price: finalPriceId,\r\n          quantity: 1\r\n        }\r\n      ],\r\n      mode: 'subscription',\r\n      success_url: successUrl,\r\n      cancel_url: cancelUrl,\r\n      customer_email: customerEmail,\r\n      metadata: sessionMetadata,\r\n      subscription_data: {\r\n        metadata: {\r\n          restaurant_id: restaurantId,\r\n          customer_id: customerId,\r\n          tier_id: tierId || 'custom',\r\n          ...(metadata || {}) // Also add metadata to subscription\r\n        }\r\n      }\r\n    });\r\n    \r\n    return res.status(200).json({ id: session.id });\r\n  } catch (error: any) {\r\n    console.error('Error creating checkout session:', error);\r\n    return res.status(500).json({ error: error.message || 'Internal server error' });\r\n  }\r\n}\r\n\r\nexport default async function handler(req: VercelRequest, res: VercelResponse) {\r\n  if (req.method === 'POST') {\r\n    return createCheckoutSession(req, res);\r\n  } else {\r\n    return res.status(405).json({ error: 'Method not allowed' });\r\n  }\r\n}\r\n", "import Stripe from 'stripe';\r\n\r\n// Check if the Stripe secret key is configured\r\nconst stripeSecretKey = process.env.STRIPE_SECRET_KEY;\r\n\r\nif (!stripeSecretKey) {\r\n  console.error('STRIPE_SECRET_KEY is not configured in environment variables');\r\n}\r\n\r\n// Initialize Stripe for server-side operations with proper configuration\r\nexport const stripe = new Stripe(stripeSecretKey || 'invalid_key', {\r\n  apiVersion: '2025-02-24.acacia', // Using latest API version\r\n  maxNetworkRetries: 3, // Retry on network failures for better reliability\r\n});", "import { createClient } from '@supabase/supabase-js';\r\n\r\n// Initialize Supabase with service role key for admin operations\r\nexport const supabaseAdmin = createClient(\r\n  process.env.SUPABASE_URL as string,\r\n  process.env.SUPABASE_SERVICE_ROLE_KEY as string,\r\n  {\r\n    auth: {\r\n      autoRefreshToken: false,\r\n      persistSession: false\r\n    }\r\n  }\r\n); ", "// API request validation utilities\r\n\r\nexport interface ValidationError {\r\n  field: string;\r\n  message: string;\r\n}\r\n\r\nexport function validateRequired(\r\n  data: Record<string, any>,\r\n  requiredFields: string[]\r\n): ValidationError[] {\r\n  const errors: ValidationError[] = [];\r\n  \r\n  for (const field of requiredFields) {\r\n    const value = data[field];\r\n    if (value === undefined || value === null || value === '') {\r\n      errors.push({\r\n        field,\r\n        message: `${field} is required`,\r\n      });\r\n    }\r\n  }\r\n  \r\n  return errors;\r\n}\r\n\r\nexport function validateEmail(email: string): boolean {\r\n  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\r\n  return emailRegex.test(email);\r\n}\r\n\r\nexport function validatePrice(price: string | number): boolean {\r\n  if (typeof price === 'number') {\r\n    return price > 0;\r\n  }\r\n  const priceNum = parseFloat(price);\r\n  return !isNaN(priceNum) && priceNum > 0;\r\n}\r\n\r\nexport function validateRequest(\r\n  data: Record<string, any>,\r\n  requiredFields: string[],\r\n  customValidators?: {\r\n    [field: string]: (value: any) => ValidationError | null;\r\n  }\r\n): { isValid: boolean; errors: ValidationError[] } {\r\n  const errors: ValidationError[] = validateRequired(data, requiredFields);\r\n  \r\n  // Run custom validators if provided\r\n  if (customValidators) {\r\n    for (const [field, validator] of Object.entries(customValidators)) {\r\n      if (data[field] !== undefined && data[field] !== null) {\r\n        const validationResult = validator(data[field]);\r\n        if (validationResult) {\r\n          errors.push(validationResult);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors,\r\n  };\r\n}\r\n"],
  "mappings": "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",
  "names": ["Stripe"]
}
