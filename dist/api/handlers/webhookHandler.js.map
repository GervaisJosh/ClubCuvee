{
  "version": 3,
  "sources": ["webhookHandler.ts", "../utils/stripeClient.ts", "../../lib/supabaseAdmin.ts", "../utils/errorHandler.ts"],
  "sourcesContent": ["import { stripe } from '../utils/stripeClient';\r\nimport { supabaseAdmin } from '@/lib/supabaseAdmin';\r\nimport type { VercelRequest, VercelResponse } from '@vercel/node';\r\nimport { Readable } from 'stream';\r\nimport Stripe from 'stripe';\r\nimport { z } from 'zod';\r\nimport { sendErrorResponse, AppError, handleStripeError } from '../utils/errorHandler';\r\n\r\n// Define CheckoutData type\r\ninterface CheckoutData extends Stripe.Checkout.SessionCreateParams {\r\n  idempotencyKey?: string;\r\n}\r\n\r\n// For verifying Stripe signatures, we need the raw request body\r\nasync function readRawBody(readable: Readable) {\r\n  const chunks: Buffer[] = [];\r\n  for await (const chunk of readable) {\r\n    chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk);\r\n  }\r\n  return Buffer.concat(chunks);\r\n}\r\n\r\n// Rate limiting configuration\r\ninterface RateLimitConfig {\r\n  windowMs: number;\r\n  maxRequests: number;\r\n}\r\n\r\nconst RATE_LIMITS: Record<string, RateLimitConfig> = {\r\n  default: {\r\n    windowMs: 15 * 60 * 1000, // 15 minutes\r\n    maxRequests: 100\r\n  },\r\n  'checkout.session.completed': {\r\n    windowMs: 5 * 60 * 1000, // 5 minutes\r\n    maxRequests: 50\r\n  },\r\n  'customer.subscription.updated': {\r\n    windowMs: 5 * 60 * 1000,\r\n    maxRequests: 50\r\n  }\r\n};\r\n\r\ninterface RateLimitEntry {\r\n  count: number;\r\n  resetTime: number;\r\n}\r\n\r\nconst requestCounts = new Map<string, RateLimitEntry>();\r\n\r\nfunction cleanupExpiredEntries() {\r\n  const now = Date.now();\r\n  for (const [key, entry] of requestCounts.entries()) {\r\n    if (now > entry.resetTime) {\r\n      requestCounts.delete(key);\r\n    }\r\n  }\r\n}\r\n\r\nfunction isRateLimited(ip: string, eventType: string): boolean {\r\n  cleanupExpiredEntries();\r\n  \r\n  const config = RATE_LIMITS[eventType] || RATE_LIMITS.default;\r\n  const key = `${ip}:${eventType}`;\r\n  const now = Date.now();\r\n  \r\n  const entry = requestCounts.get(key);\r\n  if (!entry) {\r\n    requestCounts.set(key, {\r\n      count: 1,\r\n      resetTime: now + config.windowMs\r\n    });\r\n    return false;\r\n  }\r\n  \r\n  if (now > entry.resetTime) {\r\n    requestCounts.set(key, {\r\n      count: 1,\r\n      resetTime: now + config.windowMs\r\n    });\r\n    return false;\r\n  }\r\n  \r\n  if (entry.count >= config.maxRequests) {\r\n    return true;\r\n  }\r\n  \r\n  entry.count++;\r\n  return false;\r\n}\r\n\r\n/**\r\n * Handle Stripe webhook events\r\n */\r\nexport async function handleWebhook(req: VercelRequest, res: VercelResponse) {\r\n  try {\r\n    if (req.method !== 'POST') {\r\n      throw new AppError(405, 'Method not allowed');\r\n    }\r\n\r\n    // Apply rate limiting\r\n    const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress;\r\n    if (typeof ip === 'string' && isRateLimited(ip, 'default')) {\r\n      throw new AppError(429, 'Too many requests');\r\n    }\r\n\r\n    // 1. Read raw body\r\n    const rawBody = await readRawBody(req);\r\n    const signature = req.headers['stripe-signature'] as string;\r\n\r\n    // 2. Construct event with Stripe\r\n    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\r\n    if (!webhookSecret) {\r\n      throw new Error('Missing STRIPE_WEBHOOK_SECRET environment variable');\r\n    }\r\n    \r\n    const event = stripe.webhooks.constructEvent(\r\n      rawBody,\r\n      signature,\r\n      webhookSecret\r\n    );\r\n\r\n    // Apply event-specific rate limiting after verifying the event\r\n    if (typeof ip === 'string' && isRateLimited(ip, event.type)) {\r\n      throw new AppError(429, 'Too many requests for this event type');\r\n    }\r\n\r\n    // 3. Handle the event\r\n    console.log(`Processing webhook event: ${event.type}`);\r\n    \r\n    switch (event.type) {\r\n      case 'checkout.session.completed': {\r\n        await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session);\r\n        break;\r\n      }\r\n\r\n      case 'customer.subscription.updated': {\r\n        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);\r\n        break;\r\n      }\r\n\r\n      case 'customer.subscription.deleted': {\r\n        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);\r\n        break;\r\n      }\r\n\r\n      case 'invoice.payment_succeeded': {\r\n        await handlePaymentSucceeded(event.data.object as Stripe.Invoice);\r\n        break;\r\n      }\r\n\r\n      case 'invoice.payment_failed': {\r\n        await handlePaymentFailed(event.data.object as Stripe.Invoice);\r\n        break;\r\n      }\r\n\r\n      default:\r\n        console.log(`Unhandled event type: ${event.type}`);\r\n    }\r\n\r\n    // Acknowledge receipt of the event\r\n    return res.status(200).json({ received: true });\r\n  } catch (error) {\r\n    return sendErrorResponse(res, error instanceof Error ? error : new Error(String(error)));\r\n  }\r\n}\r\n\r\n/**\r\n * Handle checkout.session.completed event\r\n */\r\nasync function handleCheckoutCompleted(session: Stripe.Checkout.Session) {\r\n  if (!session.metadata?.customer_id || !session.metadata?.restaurant_id) {\r\n    throw new AppError(400, 'Missing required metadata in session');\r\n  }\r\n\r\n  try {\r\n    // Start a Supabase transaction\r\n    const { data: customer, error: customerError } = await supabaseAdmin\r\n      .from('customers')\r\n      .select('*')\r\n      .eq('id', session.metadata.customer_id)\r\n      .single();\r\n\r\n    if (customerError) throw customerError;\r\n    if (!customer) throw new AppError(404, 'Customer not found');\r\n\r\n    // Update customer with Stripe data\r\n    const { error: updateError } = await supabaseAdmin\r\n      .from('customers')\r\n      .update({\r\n        stripe_customer_id: session.customer as string,\r\n        stripe_subscription_id: session.subscription as string,\r\n        subscription_status: 'active',\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .eq('id', session.metadata.customer_id);\r\n\r\n    if (updateError) throw updateError;\r\n\r\n    // Update restaurant status\r\n    const { error: restaurantError } = await supabaseAdmin\r\n      .from('restaurants')\r\n      .update({\r\n        status: 'active',\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .eq('id', session.metadata.restaurant_id);\r\n\r\n    if (restaurantError) throw restaurantError;\r\n\r\n  } catch (error) {\r\n    console.error('Error processing checkout completed:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Handle customer.subscription.updated event\r\n */\r\nasync function handleSubscriptionUpdated(subscription: Stripe.Subscription) {\r\n  const { customer_id, restaurant_id } = subscription.metadata || {};\r\n  \r\n  if (!customer_id) {\r\n    // Try to get metadata from the Stripe customer\r\n    const customerId = subscription.customer as string;\r\n    try {\r\n      const customer = await stripe.customers.retrieve(customerId);\r\n      const metadata = (customer as Stripe.Customer).metadata;\r\n      \r\n      if (metadata.customer_id) {\r\n        await updateSubscriptionByCustomerId(metadata.customer_id, subscription);\r\n        return;\r\n      }\r\n    } catch (err) {\r\n      console.error('Error fetching Stripe customer:', err);\r\n    }\r\n    \r\n    console.error('Missing customer_id in subscription metadata');\r\n    return;\r\n  }\r\n\r\n  await updateSubscriptionByCustomerId(customer_id, subscription);\r\n}\r\n\r\n/**\r\n * Update subscription status by customer ID\r\n */\r\nasync function updateSubscriptionByCustomerId(customerId: string, subscription: Stripe.Subscription) {\r\n  // First try updating by subscription ID\r\n  const { error: subIdError, count } = await supabaseAdmin\r\n    .from('customers')\r\n    .update({\r\n      subscription_status: subscription.status,\r\n      current_period_end: subscription.current_period_end \r\n        ? new Date(subscription.current_period_end * 1000).toISOString() \r\n        : null,\r\n      updated_at: new Date().toISOString(),\r\n    })\r\n    .eq('stripe_subscription_id', subscription.id)\r\n    .select('count');\r\n\r\n  if (subIdError) {\r\n    console.error('Error updating subscription by ID:', subIdError);\r\n  }\r\n\r\n  // If no records updated by subscription ID, try by customer_id from metadata\r\n  if (!count) {\r\n    const { error: custIdError } = await supabaseAdmin\r\n      .from('customers')\r\n      .update({\r\n        stripe_subscription_id: subscription.id,\r\n        subscription_status: subscription.status,\r\n        current_period_end: subscription.current_period_end \r\n          ? new Date(subscription.current_period_end * 1000).toISOString() \r\n          : null,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', customerId);\r\n\r\n    if (custIdError) {\r\n      console.error('Error updating subscription by customer ID:', custIdError);\r\n      throw custIdError;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Handle customer.subscription.deleted event\r\n */\r\nasync function handleSubscriptionDeleted(subscription: Stripe.Subscription) {\r\n  const { customer_id } = subscription.metadata || {};\r\n  \r\n  if (!customer_id) {\r\n    // Try to get metadata from the Stripe customer\r\n    const customerId = subscription.customer as string;\r\n    try {\r\n      const customer = await stripe.customers.retrieve(customerId);\r\n      const metadata = (customer as Stripe.Customer).metadata;\r\n      \r\n      if (metadata.customer_id) {\r\n        await updateSubscriptionCancellation(metadata.customer_id, subscription);\r\n        return;\r\n      }\r\n    } catch (err) {\r\n      console.error('Error fetching Stripe customer:', err);\r\n    }\r\n    \r\n    console.error('Missing customer_id in subscription metadata');\r\n    return;\r\n  }\r\n\r\n  await updateSubscriptionCancellation(customer_id, subscription);\r\n}\r\n\r\n/**\r\n * Update subscription cancellation by customer ID\r\n */\r\nasync function updateSubscriptionCancellation(customerId: string, subscription: Stripe.Subscription) {\r\n  const canceledAt = subscription.canceled_at\r\n    ? new Date(subscription.canceled_at * 1000).toISOString()\r\n    : new Date().toISOString();\r\n\r\n  const { error: updateError } = await supabaseAdmin\r\n    .from('customers')\r\n    .update({\r\n      subscription_status: 'canceled',\r\n      subscription_end_date: canceledAt,\r\n      updated_at: new Date().toISOString(),\r\n    })\r\n    .eq('stripe_subscription_id', subscription.id);\r\n\r\n  if (updateError) {\r\n    console.error('Error updating subscription cancellation:', updateError);\r\n    throw updateError;\r\n  }\r\n}\r\n\r\n/**\r\n * Handle invoice.payment_succeeded event\r\n */\r\nasync function handlePaymentSucceeded(invoice: Stripe.Invoice) {\r\n  if (!invoice.subscription) return;\r\n\r\n  try {\r\n    // Record payment in your \"subscription_payments\" table\r\n    const { error } = await supabaseAdmin\r\n      .from('subscription_payments')\r\n      .insert([{\r\n        stripe_invoice_id: invoice.id,\r\n        stripe_subscription_id: invoice.subscription,\r\n        stripe_customer_id: invoice.customer,\r\n        amount: invoice.amount_paid / 100, // from cents\r\n        currency: invoice.currency,\r\n        status: invoice.status,\r\n        payment_date: new Date(invoice.created * 1000).toISOString(),\r\n        created_at: new Date().toISOString(),\r\n      }]);\r\n\r\n    if (error) {\r\n      console.error('Error recording subscription payment:', error);\r\n      // Don't throw, as this is non-critical\r\n    }\r\n  } catch (error) {\r\n    console.error('Error processing payment succeeded event:', error);\r\n    // Don't throw to avoid webhook failure\r\n  }\r\n}\r\n\r\n/**\r\n * Handle invoice.payment_failed event\r\n */\r\nasync function handlePaymentFailed(invoice: Stripe.Invoice) {\r\n  if (!invoice.subscription) return;\r\n\r\n  try {\r\n    // Find the matching customer by subscription\r\n    const { data: foundCustomer, error: custError } = await supabaseAdmin\r\n      .from('customers')\r\n      .select('id, email')\r\n      .eq('stripe_subscription_id', invoice.subscription)\r\n      .maybeSingle();\r\n\r\n    if (custError) {\r\n      console.error('Error finding customer for failed payment:', custError);\r\n      return;\r\n    }\r\n    \r\n    if (!foundCustomer) {\r\n      console.error('No matching customer found for failed payment');\r\n      return;\r\n    }\r\n\r\n    // Mark subscription as past_due\r\n    const { error: updateError } = await supabaseAdmin\r\n      .from('customers')\r\n      .update({\r\n        subscription_status: 'past_due',\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', foundCustomer.id);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating customer subscription status:', updateError);\r\n      throw updateError;\r\n    }\r\n\r\n    // Optionally, send an email to the customer about the failed payment\r\n    // if (foundCustomer.email) {\r\n    //   await sendFailedPaymentEmail(foundCustomer.email, {\r\n    //     amount: invoice.amount_due / 100,\r\n    //     currency: invoice.currency\r\n    //   });\r\n    // }\r\n  } catch (error) {\r\n    console.error('Error processing payment failed event:', error);\r\n    // Don't throw to avoid webhook failure\r\n  }\r\n}\r\n\r\nconst InvitationSchema = z.object({\r\n  email: z.string().email(),\r\n  restaurant_name: z.string().min(1),\r\n  // ... other fields\r\n});\r\n\r\nconst createCheckoutSession = async (data: CheckoutData) => {\r\n  const idempotencyKey = crypto.randomUUID();\r\n  return stripe.checkout.sessions.create(data, {\r\n    idempotencyKey\r\n  });\r\n};\r\n\r\nexport default handleWebhook;", "import Stripe from 'stripe';\r\nimport { handleStripeError } from '@/lib/utils/errorHandler';\r\n\r\nconst stripeSecretKey = process.env.STRIPE_SECRET_KEY;\r\nif (!stripeSecretKey) {\r\n  console.error('STRIPE_SECRET_KEY is not configured in environment variables');\r\n}\r\n\r\nexport const stripe = new Stripe(stripeSecretKey || 'invalid_key', {\r\n  apiVersion: '2025-02-24.acacia',\r\n  maxNetworkRetries: 3,\r\n  typescript: true,\r\n  appInfo: {\r\n    name: 'Club Cuvee',\r\n    version: '1.0.0'\r\n  }\r\n});\r\n\r\n// Wrapper for Stripe API calls with error handling\r\nexport const stripeApi = {\r\n  createCheckoutSession: async (data: Stripe.Checkout.SessionCreateParams) => {\r\n    try {\r\n      const idempotencyKey = crypto.randomUUID();\r\n      return await stripe.checkout.sessions.create(data, {\r\n        idempotencyKey\r\n      });\r\n    } catch (error) {\r\n      throw handleStripeError(error);\r\n    }\r\n  },\r\n\r\n  createCustomer: async (data: Stripe.CustomerCreateParams) => {\r\n    try {\r\n      const idempotencyKey = crypto.randomUUID();\r\n      return await stripe.customers.create(data, {\r\n        idempotencyKey\r\n      });\r\n    } catch (error) {\r\n      throw handleStripeError(error);\r\n    }\r\n  },\r\n\r\n  createSubscription: async (data: Stripe.SubscriptionCreateParams) => {\r\n    try {\r\n      const idempotencyKey = crypto.randomUUID();\r\n      return await stripe.subscriptions.create(data, {\r\n        idempotencyKey\r\n      });\r\n    } catch (error) {\r\n      throw handleStripeError(error);\r\n    }\r\n  },\r\n\r\n  constructEvent: async (payload: string | Buffer, signature: string, secret: string) => {\r\n    try {\r\n      return stripe.webhooks.constructEvent(payload, signature, secret);\r\n    } catch (error) {\r\n      throw handleStripeError(error);\r\n    }\r\n  }\r\n};", "import { createClient } from '@supabase/supabase-js';\r\n\r\n// Initialize Supabase with service role key for admin operations\r\nexport const supabaseAdmin = createClient(\r\n  process.env.SUPABASE_URL as string,\r\n  process.env.SUPABASE_SERVICE_ROLE_KEY as string,\r\n  {\r\n    auth: {\r\n      autoRefreshToken: false,\r\n      persistSession: false\r\n    }\r\n  }\r\n); ", "import type { VercelResponse } from '@vercel/node';\r\nimport { ZodError } from 'zod';\r\n\r\nexport interface ApiErrorResponse {\r\n  status: 'error';\r\n  error: string;\r\n  code?: number;\r\n  type?: string;\r\n  details?: any;\r\n  deployment_url?: string;\r\n  errorDetails?: any;\r\n}\r\n\r\nexport class AppError extends Error {\r\n  constructor(\r\n    public statusCode: number,\r\n    message: string,\r\n    public isOperational = true\r\n  ) {\r\n    super(message);\r\n    Object.setPrototypeOf(this, AppError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Formats an error into a consistent API error response\r\n * \r\n * @param error The error object to format\r\n * @param includeDetails Whether to include detailed error information (default: false)\r\n * @returns A structured API error response object\r\n */\r\nexport function formatApiError(error: any, includeDetails = false): ApiErrorResponse {\r\n  // Extract common error properties\r\n  const errorResponse: ApiErrorResponse = {\r\n    status: 'error',\r\n    error: error.message || 'Internal server error',\r\n  };\r\n\r\n  // Add error type if available\r\n  if (error.type) {\r\n    errorResponse.type = error.type;\r\n  }\r\n\r\n  // Add error code if available\r\n  if (error.code || error.statusCode) {\r\n    errorResponse.code = error.code || error.statusCode;\r\n  }\r\n\r\n  // Include deployment context to help with debugging\r\n  const deployUrl = process.env.VERCEL_URL || process.env.FRONTEND_URL;\r\n  if (deployUrl) {\r\n    errorResponse.deployment_url = deployUrl.startsWith('http') ? deployUrl : `https://${deployUrl}`;\r\n  }\r\n\r\n  // Include detailed error information in development mode\r\n  if (includeDetails || process.env.NODE_ENV === 'development') {\r\n    errorResponse.errorDetails = {\r\n      message: error.message,\r\n      code: error.code,\r\n      type: error.type,\r\n      stack: error.stack,\r\n      // Additional properties that might be useful\r\n      name: error.name,\r\n      cause: error.cause,\r\n    };\r\n  }\r\n\r\n  return errorResponse;\r\n}\r\n\r\n/**\r\n * Sends a formatted error response\r\n * \r\n * @param res The Vercel response object\r\n * @param error The error to format and send\r\n * @param statusCode The HTTP status code to use (default: 500)\r\n * @param includeDetails Whether to include detailed error information (default: false)\r\n */\r\nexport function sendApiError(\r\n  res: VercelResponse,\r\n  error: any,\r\n  statusCode = 500,\r\n  includeDetails = false\r\n): void {\r\n  // Log the error for server-side debugging\r\n  console.error(`API Error (${statusCode}):`, error);\r\n  \r\n  // Send the formatted error response\r\n  res.status(statusCode).json(formatApiError(error, includeDetails));\r\n}\r\n\r\n/**\r\n * Returns common error status codes based on error types\r\n * \r\n * @param error The error to analyze\r\n * @returns An appropriate HTTP status code\r\n */\r\nexport function getErrorStatusCode(error: any): number {\r\n  // Authentication errors\r\n  if (\r\n    error.type === 'StripeAuthenticationError' ||\r\n    error.message?.toLowerCase().includes('authentication') ||\r\n    error.message?.toLowerCase().includes('api key') ||\r\n    error.code === 'auth_error'\r\n  ) {\r\n    return 401;\r\n  }\r\n\r\n  // Validation errors\r\n  if (\r\n    error.type === 'StripeInvalidRequestError' || \r\n    error.message?.toLowerCase().includes('validation') ||\r\n    error.message?.toLowerCase().includes('invalid')\r\n  ) {\r\n    return 400;\r\n  }\r\n\r\n  // Resource not found\r\n  if (\r\n    error.type === 'StripeInvalidRequestError' && \r\n    error.message?.toLowerCase().includes('no such') ||\r\n    error.code === 'resource_missing'\r\n  ) {\r\n    return 404;\r\n  }\r\n\r\n  // Rate limiting errors\r\n  if (\r\n    error.type === 'StripeRateLimitError' ||\r\n    error.code === 'rate_limit_exceeded'\r\n  ) {\r\n    return 429;\r\n  }\r\n\r\n  // External service errors\r\n  if (\r\n    error.type === 'StripeAPIError' ||\r\n    error.type === 'StripeConnectionError'\r\n  ) {\r\n    return 502;\r\n  }\r\n\r\n  // Default to internal server error\r\n  return 500;\r\n}\r\n\r\n/**\r\n * Wrapper for API handler functions to catch and format errors consistently\r\n * \r\n * @param handler The API handler function to wrap\r\n * @returns A wrapped handler function with error handling\r\n */\r\nexport function withErrorHandling(\r\n  handler: (req: any, res: any) => Promise<any>\r\n) {\r\n  return async (req: any, res: any) => {\r\n    try {\r\n      return await handler(req, res);\r\n    } catch (error: any) {\r\n      const statusCode = getErrorStatusCode(error);\r\n      sendApiError(res, error, statusCode);\r\n    }\r\n  };\r\n}\r\n\r\nexport const sendErrorResponse = (\r\n  res: VercelResponse,\r\n  error: Error | AppError | ZodError,\r\n  statusCode = 500\r\n) => {\r\n  // Set CORS headers\r\n  res.setHeader('Access-Control-Allow-Origin', '*');\r\n  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\r\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\r\n\r\n  // Handle preflight requests\r\n  if (res.req?.method === 'OPTIONS') {\r\n    return res.status(204).end();\r\n  }\r\n\r\n  // Handle Zod validation errors\r\n  if (error instanceof ZodError) {\r\n    return res.status(400).json({\r\n      error: 'Validation Error',\r\n      details: error.errors.map(err => ({\r\n        path: err.path.join('.'),\r\n        message: err.message\r\n      }))\r\n    });\r\n  }\r\n\r\n  // Handle operational errors (expected errors)\r\n  if (error instanceof AppError && error.isOperational) {\r\n    return res.status(error.statusCode).json({\r\n      error: error.message\r\n    });\r\n  }\r\n\r\n  // Handle unexpected errors\r\n  console.error('Unexpected error:', error);\r\n  return res.status(statusCode).json({\r\n    error: process.env.NODE_ENV === 'production' \r\n      ? 'An unexpected error occurred' \r\n      : error.message\r\n  });\r\n};\r\n\r\nexport const handleStripeError = (error: any) => {\r\n  if (error.type?.startsWith('Stripe')) {\r\n    throw new AppError(400, error.message);\r\n  }\r\n  throw error;\r\n};"],
  "mappings": "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",
  "names": ["Stripe", "import_zod"]
}
