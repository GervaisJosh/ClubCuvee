{
  "version": 3,
  "sources": ["../../../api/handlers/webhookHandler.ts", "../../../api/utils/stripeClient.ts", "../../../lib/supabaseAdmin.ts"],
  "sourcesContent": ["import { stripe } from '../utils/stripeClient';\r\nimport { supabaseAdmin } from '@/lib/supabaseAdmin';\r\nimport type { VercelRequest, VercelResponse } from '@vercel/node';\r\nimport { Readable } from 'stream';\r\nimport Stripe from 'stripe';\r\n\r\n// For verifying Stripe signatures, we need the raw request body\r\nasync function readRawBody(readable: Readable) {\r\n  const chunks: Buffer[] = [];\r\n  for await (const chunk of readable) {\r\n    chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk);\r\n  }\r\n  return Buffer.concat(chunks);\r\n}\r\n\r\n/**\r\n * Handle Stripe webhook events\r\n */\r\nexport async function handleWebhook(req: VercelRequest, res: VercelResponse) {\r\n  if (req.method !== 'POST') {\r\n    return res.status(405).json({ error: 'Method not allowed' });\r\n  }\r\n\r\n  let event: Stripe.Event;\r\n  try {\r\n    // 1. Read raw body\r\n    const rawBody = await readRawBody(req);\r\n    const signature = req.headers['stripe-signature'] as string;\r\n\r\n    // 2. Construct event with Stripe\r\n    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\r\n    if (!webhookSecret) {\r\n      throw new Error('Missing STRIPE_WEBHOOK_SECRET environment variable');\r\n    }\r\n    \r\n    event = stripe.webhooks.constructEvent(\r\n      rawBody,\r\n      signature,\r\n      webhookSecret\r\n    );\r\n  } catch (err: any) {\r\n    console.error('\u274C Error verifying Stripe webhook signature:', err.message);\r\n    return res.status(400).send(`Webhook Error: ${err.message}`);\r\n  }\r\n\r\n  // 3. Handle the event\r\n  try {\r\n    console.log(`Processing webhook event: ${event.type}`);\r\n    \r\n    switch (event.type) {\r\n      case 'checkout.session.completed': {\r\n        await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session);\r\n        break;\r\n      }\r\n\r\n      case 'customer.subscription.updated': {\r\n        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);\r\n        break;\r\n      }\r\n\r\n      case 'customer.subscription.deleted': {\r\n        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);\r\n        break;\r\n      }\r\n\r\n      case 'invoice.payment_succeeded': {\r\n        await handlePaymentSucceeded(event.data.object as Stripe.Invoice);\r\n        break;\r\n      }\r\n\r\n      case 'invoice.payment_failed': {\r\n        await handlePaymentFailed(event.data.object as Stripe.Invoice);\r\n        break;\r\n      }\r\n\r\n      default:\r\n        // Unexpected event type\r\n        console.log(`Unhandled event type: ${event.type}`);\r\n    }\r\n\r\n    // Acknowledge receipt of the event\r\n    return res.status(200).json({ received: true });\r\n  } catch (error: any) {\r\n    console.error('Error handling Stripe webhook:', error);\r\n    return res.status(500).json({ error: error.message || 'Internal server error' });\r\n  }\r\n}\r\n\r\n/** \r\n * Handle checkout.session.completed event \r\n */\r\nasync function handleCheckoutCompleted(session: Stripe.Checkout.Session) {\r\n  // Extract metadata\r\n  const { customer_id, restaurant_id, type } = session.metadata || {};\r\n\r\n  if (!customer_id || !restaurant_id) {\r\n    console.error('Missing metadata (customer_id or restaurant_id) in session');\r\n    return;\r\n  }\r\n\r\n  // Check session type - could be a restaurant onboarding payment or customer subscription\r\n  const isRestaurantOnboarding = type === 'restaurant_onboarding';\r\n  \r\n  if (isRestaurantOnboarding) {\r\n    console.log(`Processing restaurant onboarding payment for restaurant_id: ${restaurant_id}`);\r\n    \r\n    // Update restaurant record if this is an onboarding payment\r\n    const { error: restaurantError } = await supabaseAdmin\r\n      .from('restaurants')\r\n      .update({\r\n        payment_session_id: session.id,\r\n        payment_completed: true,\r\n        payment_date: new Date().toISOString(),\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', restaurant_id);\r\n      \r\n    if (restaurantError) {\r\n      console.error('Error updating restaurant after checkout:', restaurantError);\r\n      throw restaurantError;\r\n    }\r\n    \r\n    // Check for pending invitation token and update\r\n    if (session.metadata?.invitation_token) {\r\n      await supabaseAdmin\r\n        .from('restaurant_invitations')\r\n        .update({\r\n          status: 'paid',\r\n          payment_session_id: session.id,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('token', session.metadata.invitation_token);\r\n    }\r\n  } else {\r\n    console.log(`Processing customer subscription for customer_id: ${customer_id}`);\r\n    \r\n    // Create a new Stripe customer if one doesn't exist yet\r\n    let stripeCustomerId = session.customer as string;\r\n    \r\n    if (!stripeCustomerId && session.customer_email) {\r\n      // Create a new Stripe customer from the email\r\n      const newCustomer = await stripe.customers.create({\r\n        email: session.customer_email,\r\n        metadata: {\r\n          customer_id,\r\n          restaurant_id,\r\n        }\r\n      });\r\n      stripeCustomerId = newCustomer.id;\r\n    }\r\n    \r\n    // Regular customer subscription payment\r\n    const { error: updateError } = await supabaseAdmin\r\n      .from('customers')\r\n      .update({\r\n        stripe_customer_id: stripeCustomerId,\r\n        stripe_subscription_id: session.subscription as string,\r\n        subscription_status: 'active',\r\n        subscription_start_date: new Date().toISOString(),\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', customer_id);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating customer after checkout:', updateError);\r\n      throw updateError;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Handle customer.subscription.updated event\r\n */\r\nasync function handleSubscriptionUpdated(subscription: Stripe.Subscription) {\r\n  const { customer_id, restaurant_id } = subscription.metadata || {};\r\n  \r\n  if (!customer_id) {\r\n    // Try to get metadata from the Stripe customer\r\n    const customerId = subscription.customer as string;\r\n    try {\r\n      const customer = await stripe.customers.retrieve(customerId);\r\n      const metadata = (customer as Stripe.Customer).metadata;\r\n      \r\n      if (metadata.customer_id) {\r\n        await updateSubscriptionByCustomerId(metadata.customer_id, subscription);\r\n        return;\r\n      }\r\n    } catch (err) {\r\n      console.error('Error fetching Stripe customer:', err);\r\n    }\r\n    \r\n    console.error('Missing customer_id in subscription metadata');\r\n    return;\r\n  }\r\n\r\n  await updateSubscriptionByCustomerId(customer_id, subscription);\r\n}\r\n\r\n/**\r\n * Update subscription status by customer ID\r\n */\r\nasync function updateSubscriptionByCustomerId(customerId: string, subscription: Stripe.Subscription) {\r\n  // First try updating by subscription ID\r\n  const { error: subIdError, count } = await supabaseAdmin\r\n    .from('customers')\r\n    .update({\r\n      subscription_status: subscription.status,\r\n      current_period_end: subscription.current_period_end \r\n        ? new Date(subscription.current_period_end * 1000).toISOString() \r\n        : null,\r\n      updated_at: new Date().toISOString(),\r\n    })\r\n    .eq('stripe_subscription_id', subscription.id)\r\n    .select('count', { count: 'exact', head: true });\r\n\r\n  if (subIdError) {\r\n    console.error('Error updating subscription by ID:', subIdError);\r\n  }\r\n\r\n  // If no records updated by subscription ID, try by customer_id from metadata\r\n  if (!count) {\r\n    const { error: custIdError } = await supabaseAdmin\r\n      .from('customers')\r\n      .update({\r\n        stripe_subscription_id: subscription.id,\r\n        subscription_status: subscription.status,\r\n        current_period_end: subscription.current_period_end \r\n          ? new Date(subscription.current_period_end * 1000).toISOString() \r\n          : null,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', customerId);\r\n\r\n    if (custIdError) {\r\n      console.error('Error updating subscription by customer ID:', custIdError);\r\n      throw custIdError;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Handle customer.subscription.deleted event\r\n */\r\nasync function handleSubscriptionDeleted(subscription: Stripe.Subscription) {\r\n  const { customer_id } = subscription.metadata || {};\r\n  \r\n  if (!customer_id) {\r\n    // Try to get metadata from the Stripe customer\r\n    const customerId = subscription.customer as string;\r\n    try {\r\n      const customer = await stripe.customers.retrieve(customerId);\r\n      const metadata = (customer as Stripe.Customer).metadata;\r\n      \r\n      if (metadata.customer_id) {\r\n        await updateSubscriptionCancellation(metadata.customer_id, subscription);\r\n        return;\r\n      }\r\n    } catch (err) {\r\n      console.error('Error fetching Stripe customer:', err);\r\n    }\r\n    \r\n    console.error('Missing customer_id in subscription metadata');\r\n    return;\r\n  }\r\n\r\n  await updateSubscriptionCancellation(customer_id, subscription);\r\n}\r\n\r\n/**\r\n * Update subscription cancellation by customer ID\r\n */\r\nasync function updateSubscriptionCancellation(customerId: string, subscription: Stripe.Subscription) {\r\n  const canceledAt = subscription.canceled_at\r\n    ? new Date(subscription.canceled_at * 1000).toISOString()\r\n    : new Date().toISOString();\r\n\r\n  const { error: updateError } = await supabaseAdmin\r\n    .from('customers')\r\n    .update({\r\n      subscription_status: 'canceled',\r\n      subscription_end_date: canceledAt,\r\n      updated_at: new Date().toISOString(),\r\n    })\r\n    .eq('stripe_subscription_id', subscription.id);\r\n\r\n  if (updateError) {\r\n    console.error('Error updating subscription cancellation:', updateError);\r\n    throw updateError;\r\n  }\r\n}\r\n\r\n/**\r\n * Handle invoice.payment_succeeded event\r\n */\r\nasync function handlePaymentSucceeded(invoice: Stripe.Invoice) {\r\n  if (!invoice.subscription) return;\r\n\r\n  try {\r\n    // Record payment in your \"subscription_payments\" table\r\n    const { error } = await supabaseAdmin\r\n      .from('subscription_payments')\r\n      .insert([{\r\n        stripe_invoice_id: invoice.id,\r\n        stripe_subscription_id: invoice.subscription,\r\n        stripe_customer_id: invoice.customer,\r\n        amount: invoice.amount_paid / 100, // from cents\r\n        currency: invoice.currency,\r\n        status: invoice.status,\r\n        payment_date: new Date(invoice.created * 1000).toISOString(),\r\n        created_at: new Date().toISOString(),\r\n      }]);\r\n\r\n    if (error) {\r\n      console.error('Error recording subscription payment:', error);\r\n      // Don't throw, as this is non-critical\r\n    }\r\n  } catch (error) {\r\n    console.error('Error processing payment succeeded event:', error);\r\n    // Don't throw to avoid webhook failure\r\n  }\r\n}\r\n\r\n/**\r\n * Handle invoice.payment_failed event\r\n */\r\nasync function handlePaymentFailed(invoice: Stripe.Invoice) {\r\n  if (!invoice.subscription) return;\r\n\r\n  try {\r\n    // Find the matching customer by subscription\r\n    const { data: foundCustomer, error: custError } = await supabaseAdmin\r\n      .from('customers')\r\n      .select('id, email')\r\n      .eq('stripe_subscription_id', invoice.subscription)\r\n      .maybeSingle();\r\n\r\n    if (custError) {\r\n      console.error('Error finding customer for failed payment:', custError);\r\n      return;\r\n    }\r\n    \r\n    if (!foundCustomer) {\r\n      console.error('No matching customer found for failed payment');\r\n      return;\r\n    }\r\n\r\n    // Mark subscription as past_due\r\n    const { error: updateError } = await supabaseAdmin\r\n      .from('customers')\r\n      .update({\r\n        subscription_status: 'past_due',\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', foundCustomer.id);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating customer subscription status:', updateError);\r\n      throw updateError;\r\n    }\r\n\r\n    // Optionally, send an email to the customer about the failed payment\r\n    // if (foundCustomer.email) {\r\n    //   await sendFailedPaymentEmail(foundCustomer.email, {\r\n    //     amount: invoice.amount_due / 100,\r\n    //     currency: invoice.currency\r\n    //   });\r\n    // }\r\n  } catch (error) {\r\n    console.error('Error processing payment failed event:', error);\r\n    // Don't throw to avoid webhook failure\r\n  }\r\n}\r\n\r\nexport default handleWebhook;", "import Stripe from 'stripe';\r\n\r\n// Check if the Stripe secret key is configured\r\nconst stripeSecretKey = process.env.STRIPE_SECRET_KEY;\r\n\r\nif (!stripeSecretKey) {\r\n  console.error('STRIPE_SECRET_KEY is not configured in environment variables');\r\n}\r\n\r\n// Initialize Stripe for server-side operations with proper configuration\r\nexport const stripe = new Stripe(stripeSecretKey || 'invalid_key', {\r\n  apiVersion: '2023-10-16', // Using a specific API version for stability\r\n  maxNetworkRetries: 3, // Retry on network failures for better reliability\r\n});", "import { createClient } from '@supabase/supabase-js';\r\n\r\n// Initialize Supabase with service role key for admin operations\r\nexport const supabaseAdmin = createClient(\r\n  process.env.SUPABASE_URL as string,\r\n  process.env.SUPABASE_SERVICE_ROLE_KEY as string,\r\n  {\r\n    auth: {\r\n      autoRefreshToken: false,\r\n      persistSession: false\r\n    }\r\n  }\r\n); "],
  "mappings": "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",
  "names": ["Stripe"]
}
