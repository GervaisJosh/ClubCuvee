{
  "version": 3,
  "sources": ["stripe-webhook.ts", "utils/stripeClient.ts", "../lib/supabaseAdmin.ts", "handlers/webhookHandler.ts", "utils/errorHandler.ts"],
  "sourcesContent": ["// File: /api/stripe-webhook.ts\r\nimport { handleWebhook } from './handlers/webhookHandler';\r\nimport type { VercelRequest, VercelResponse } from '@vercel/node';\r\nimport { withErrorHandling } from './utils/errorHandler';\r\n\r\n/**\r\n * Stripe webhook endpoint - all logic is now contained in the modular webhookHandler\r\n * This provides a clean entry point for the Vercel serverless function\r\n * Uses the withErrorHandling wrapper for consistent error responses\r\n */\r\nconst handler = async (req: VercelRequest, res: VercelResponse) => {\r\n  return handleWebhook(req, res);\r\n};\r\n\r\n// Export with error handling wrapper\r\nexport default withErrorHandling(handler);\r\n", "import Stripe from 'stripe';\r\n\r\n// Check if the Stripe secret key is configured\r\nconst stripeSecretKey = process.env.STRIPE_SECRET_KEY;\r\n\r\nif (!stripeSecretKey) {\r\n  console.error('STRIPE_SECRET_KEY is not configured in environment variables');\r\n}\r\n\r\n// Initialize Stripe for server-side operations with proper configuration\r\nexport const stripe = new Stripe(stripeSecretKey || 'invalid_key', {\r\n  apiVersion: '2025-02-24.acacia', // Using latest API version\r\n  maxNetworkRetries: 3, // Retry on network failures for better reliability\r\n});", "import { createClient } from '@supabase/supabase-js';\r\n\r\n// Initialize Supabase with service role key for admin operations\r\nexport const supabaseAdmin = createClient(\r\n  process.env.SUPABASE_URL as string,\r\n  process.env.SUPABASE_SERVICE_ROLE_KEY as string,\r\n  {\r\n    auth: {\r\n      autoRefreshToken: false,\r\n      persistSession: false\r\n    }\r\n  }\r\n); ", "import { stripe } from '../utils/stripeClient';\r\nimport { supabaseAdmin } from '@/lib/supabaseAdmin';\r\nimport type { VercelRequest, VercelResponse } from '@vercel/node';\r\nimport { Readable } from 'stream';\r\nimport Stripe from 'stripe';\r\n\r\n// For verifying Stripe signatures, we need the raw request body\r\nasync function readRawBody(readable: Readable) {\r\n  const chunks: Buffer[] = [];\r\n  for await (const chunk of readable) {\r\n    chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk);\r\n  }\r\n  return Buffer.concat(chunks);\r\n}\r\n\r\n/**\r\n * Handle Stripe webhook events\r\n */\r\nexport async function handleWebhook(req: VercelRequest, res: VercelResponse) {\r\n  if (req.method !== 'POST') {\r\n    return res.status(405).json({ error: 'Method not allowed' });\r\n  }\r\n\r\n  let event: Stripe.Event;\r\n  try {\r\n    // 1. Read raw body\r\n    const rawBody = await readRawBody(req);\r\n    const signature = req.headers['stripe-signature'] as string;\r\n\r\n    // 2. Construct event with Stripe\r\n    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\r\n    if (!webhookSecret) {\r\n      throw new Error('Missing STRIPE_WEBHOOK_SECRET environment variable');\r\n    }\r\n    \r\n    event = stripe.webhooks.constructEvent(\r\n      rawBody,\r\n      signature,\r\n      webhookSecret\r\n    );\r\n  } catch (err: any) {\r\n    console.error('\u274C Error verifying Stripe webhook signature:', err.message);\r\n    return res.status(400).send(`Webhook Error: ${err.message}`);\r\n  }\r\n\r\n  // 3. Handle the event\r\n  try {\r\n    console.log(`Processing webhook event: ${event.type}`);\r\n    \r\n    switch (event.type) {\r\n      case 'checkout.session.completed': {\r\n        await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session);\r\n        break;\r\n      }\r\n\r\n      case 'customer.subscription.updated': {\r\n        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);\r\n        break;\r\n      }\r\n\r\n      case 'customer.subscription.deleted': {\r\n        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);\r\n        break;\r\n      }\r\n\r\n      case 'invoice.payment_succeeded': {\r\n        await handlePaymentSucceeded(event.data.object as Stripe.Invoice);\r\n        break;\r\n      }\r\n\r\n      case 'invoice.payment_failed': {\r\n        await handlePaymentFailed(event.data.object as Stripe.Invoice);\r\n        break;\r\n      }\r\n\r\n      default:\r\n        // Unexpected event type\r\n        console.log(`Unhandled event type: ${event.type}`);\r\n    }\r\n\r\n    // Acknowledge receipt of the event\r\n    return res.status(200).json({ received: true });\r\n  } catch (error: any) {\r\n    console.error('Error handling Stripe webhook:', error);\r\n    return res.status(500).json({ error: error.message || 'Internal server error' });\r\n  }\r\n}\r\n\r\n/** \r\n * Handle checkout.session.completed event \r\n */\r\nasync function handleCheckoutCompleted(session: Stripe.Checkout.Session) {\r\n  // Extract metadata\r\n  const { customer_id, restaurant_id, type } = session.metadata || {};\r\n\r\n  if (!customer_id || !restaurant_id) {\r\n    console.error('Missing metadata (customer_id or restaurant_id) in session');\r\n    return;\r\n  }\r\n\r\n  // Check session type - could be a restaurant onboarding payment or customer subscription\r\n  const isRestaurantOnboarding = type === 'restaurant_onboarding';\r\n  \r\n  if (isRestaurantOnboarding) {\r\n    console.log(`Processing restaurant onboarding payment for restaurant_id: ${restaurant_id}`);\r\n    \r\n    // Update restaurant record if this is an onboarding payment\r\n    const { error: restaurantError } = await supabaseAdmin\r\n      .from('restaurants')\r\n      .update({\r\n        payment_session_id: session.id,\r\n        payment_completed: true,\r\n        payment_date: new Date().toISOString(),\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', restaurant_id);\r\n      \r\n    if (restaurantError) {\r\n      console.error('Error updating restaurant after checkout:', restaurantError);\r\n      throw restaurantError;\r\n    }\r\n    \r\n    // Check for pending invitation token and update\r\n    if (session.metadata?.invitation_token) {\r\n      await supabaseAdmin\r\n        .from('restaurant_invitations')\r\n        .update({\r\n          status: 'paid',\r\n          payment_session_id: session.id,\r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('token', session.metadata.invitation_token);\r\n    }\r\n  } else {\r\n    console.log(`Processing customer subscription for customer_id: ${customer_id}`);\r\n    \r\n    // Create a new Stripe customer if one doesn't exist yet\r\n    let stripeCustomerId = session.customer as string;\r\n    \r\n    if (!stripeCustomerId && session.customer_email) {\r\n      // Create a new Stripe customer from the email\r\n      const newCustomer = await stripe.customers.create({\r\n        email: session.customer_email,\r\n        metadata: {\r\n          customer_id,\r\n          restaurant_id,\r\n        }\r\n      });\r\n      stripeCustomerId = newCustomer.id;\r\n    }\r\n    \r\n    // Regular customer subscription payment\r\n    const { error: updateError } = await supabaseAdmin\r\n      .from('customers')\r\n      .update({\r\n        stripe_customer_id: stripeCustomerId,\r\n        stripe_subscription_id: session.subscription as string,\r\n        subscription_status: 'active',\r\n        subscription_start_date: new Date().toISOString(),\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', customer_id);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating customer after checkout:', updateError);\r\n      throw updateError;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Handle customer.subscription.updated event\r\n */\r\nasync function handleSubscriptionUpdated(subscription: Stripe.Subscription) {\r\n  const { customer_id, restaurant_id } = subscription.metadata || {};\r\n  \r\n  if (!customer_id) {\r\n    // Try to get metadata from the Stripe customer\r\n    const customerId = subscription.customer as string;\r\n    try {\r\n      const customer = await stripe.customers.retrieve(customerId);\r\n      const metadata = (customer as Stripe.Customer).metadata;\r\n      \r\n      if (metadata.customer_id) {\r\n        await updateSubscriptionByCustomerId(metadata.customer_id, subscription);\r\n        return;\r\n      }\r\n    } catch (err) {\r\n      console.error('Error fetching Stripe customer:', err);\r\n    }\r\n    \r\n    console.error('Missing customer_id in subscription metadata');\r\n    return;\r\n  }\r\n\r\n  await updateSubscriptionByCustomerId(customer_id, subscription);\r\n}\r\n\r\n/**\r\n * Update subscription status by customer ID\r\n */\r\nasync function updateSubscriptionByCustomerId(customerId: string, subscription: Stripe.Subscription) {\r\n  // First try updating by subscription ID\r\n  const { error: subIdError, count } = await supabaseAdmin\r\n    .from('customers')\r\n    .update({\r\n      subscription_status: subscription.status,\r\n      current_period_end: subscription.current_period_end \r\n        ? new Date(subscription.current_period_end * 1000).toISOString() \r\n        : null,\r\n      updated_at: new Date().toISOString(),\r\n    })\r\n    .eq('stripe_subscription_id', subscription.id)\r\n    .select('count', { count: 'exact', head: true });\r\n\r\n  if (subIdError) {\r\n    console.error('Error updating subscription by ID:', subIdError);\r\n  }\r\n\r\n  // If no records updated by subscription ID, try by customer_id from metadata\r\n  if (!count) {\r\n    const { error: custIdError } = await supabaseAdmin\r\n      .from('customers')\r\n      .update({\r\n        stripe_subscription_id: subscription.id,\r\n        subscription_status: subscription.status,\r\n        current_period_end: subscription.current_period_end \r\n          ? new Date(subscription.current_period_end * 1000).toISOString() \r\n          : null,\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', customerId);\r\n\r\n    if (custIdError) {\r\n      console.error('Error updating subscription by customer ID:', custIdError);\r\n      throw custIdError;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Handle customer.subscription.deleted event\r\n */\r\nasync function handleSubscriptionDeleted(subscription: Stripe.Subscription) {\r\n  const { customer_id } = subscription.metadata || {};\r\n  \r\n  if (!customer_id) {\r\n    // Try to get metadata from the Stripe customer\r\n    const customerId = subscription.customer as string;\r\n    try {\r\n      const customer = await stripe.customers.retrieve(customerId);\r\n      const metadata = (customer as Stripe.Customer).metadata;\r\n      \r\n      if (metadata.customer_id) {\r\n        await updateSubscriptionCancellation(metadata.customer_id, subscription);\r\n        return;\r\n      }\r\n    } catch (err) {\r\n      console.error('Error fetching Stripe customer:', err);\r\n    }\r\n    \r\n    console.error('Missing customer_id in subscription metadata');\r\n    return;\r\n  }\r\n\r\n  await updateSubscriptionCancellation(customer_id, subscription);\r\n}\r\n\r\n/**\r\n * Update subscription cancellation by customer ID\r\n */\r\nasync function updateSubscriptionCancellation(customerId: string, subscription: Stripe.Subscription) {\r\n  const canceledAt = subscription.canceled_at\r\n    ? new Date(subscription.canceled_at * 1000).toISOString()\r\n    : new Date().toISOString();\r\n\r\n  const { error: updateError } = await supabaseAdmin\r\n    .from('customers')\r\n    .update({\r\n      subscription_status: 'canceled',\r\n      subscription_end_date: canceledAt,\r\n      updated_at: new Date().toISOString(),\r\n    })\r\n    .eq('stripe_subscription_id', subscription.id);\r\n\r\n  if (updateError) {\r\n    console.error('Error updating subscription cancellation:', updateError);\r\n    throw updateError;\r\n  }\r\n}\r\n\r\n/**\r\n * Handle invoice.payment_succeeded event\r\n */\r\nasync function handlePaymentSucceeded(invoice: Stripe.Invoice) {\r\n  if (!invoice.subscription) return;\r\n\r\n  try {\r\n    // Record payment in your \"subscription_payments\" table\r\n    const { error } = await supabaseAdmin\r\n      .from('subscription_payments')\r\n      .insert([{\r\n        stripe_invoice_id: invoice.id,\r\n        stripe_subscription_id: invoice.subscription,\r\n        stripe_customer_id: invoice.customer,\r\n        amount: invoice.amount_paid / 100, // from cents\r\n        currency: invoice.currency,\r\n        status: invoice.status,\r\n        payment_date: new Date(invoice.created * 1000).toISOString(),\r\n        created_at: new Date().toISOString(),\r\n      }]);\r\n\r\n    if (error) {\r\n      console.error('Error recording subscription payment:', error);\r\n      // Don't throw, as this is non-critical\r\n    }\r\n  } catch (error) {\r\n    console.error('Error processing payment succeeded event:', error);\r\n    // Don't throw to avoid webhook failure\r\n  }\r\n}\r\n\r\n/**\r\n * Handle invoice.payment_failed event\r\n */\r\nasync function handlePaymentFailed(invoice: Stripe.Invoice) {\r\n  if (!invoice.subscription) return;\r\n\r\n  try {\r\n    // Find the matching customer by subscription\r\n    const { data: foundCustomer, error: custError } = await supabaseAdmin\r\n      .from('customers')\r\n      .select('id, email')\r\n      .eq('stripe_subscription_id', invoice.subscription)\r\n      .maybeSingle();\r\n\r\n    if (custError) {\r\n      console.error('Error finding customer for failed payment:', custError);\r\n      return;\r\n    }\r\n    \r\n    if (!foundCustomer) {\r\n      console.error('No matching customer found for failed payment');\r\n      return;\r\n    }\r\n\r\n    // Mark subscription as past_due\r\n    const { error: updateError } = await supabaseAdmin\r\n      .from('customers')\r\n      .update({\r\n        subscription_status: 'past_due',\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .eq('id', foundCustomer.id);\r\n\r\n    if (updateError) {\r\n      console.error('Error updating customer subscription status:', updateError);\r\n      throw updateError;\r\n    }\r\n\r\n    // Optionally, send an email to the customer about the failed payment\r\n    // if (foundCustomer.email) {\r\n    //   await sendFailedPaymentEmail(foundCustomer.email, {\r\n    //     amount: invoice.amount_due / 100,\r\n    //     currency: invoice.currency\r\n    //   });\r\n    // }\r\n  } catch (error) {\r\n    console.error('Error processing payment failed event:', error);\r\n    // Don't throw to avoid webhook failure\r\n  }\r\n}\r\n\r\nexport default handleWebhook;", "import type { VercelResponse } from '@vercel/node';\r\n\r\nexport interface ApiErrorResponse {\r\n  status: 'error';\r\n  error: string;\r\n  code?: number;\r\n  type?: string;\r\n  details?: any;\r\n  deployment_url?: string;\r\n  errorDetails?: any;\r\n}\r\n\r\n/**\r\n * Formats an error into a consistent API error response\r\n * \r\n * @param error The error object to format\r\n * @param includeDetails Whether to include detailed error information (default: false)\r\n * @returns A structured API error response object\r\n */\r\nexport function formatApiError(error: any, includeDetails = false): ApiErrorResponse {\r\n  // Extract common error properties\r\n  const errorResponse: ApiErrorResponse = {\r\n    status: 'error',\r\n    error: error.message || 'Internal server error',\r\n  };\r\n\r\n  // Add error type if available\r\n  if (error.type) {\r\n    errorResponse.type = error.type;\r\n  }\r\n\r\n  // Add error code if available\r\n  if (error.code || error.statusCode) {\r\n    errorResponse.code = error.code || error.statusCode;\r\n  }\r\n\r\n  // Include deployment context to help with debugging\r\n  const deployUrl = process.env.VERCEL_URL || process.env.FRONTEND_URL;\r\n  if (deployUrl) {\r\n    errorResponse.deployment_url = deployUrl.startsWith('http') ? deployUrl : `https://${deployUrl}`;\r\n  }\r\n\r\n  // Include detailed error information in development mode\r\n  if (includeDetails || process.env.NODE_ENV === 'development') {\r\n    errorResponse.errorDetails = {\r\n      message: error.message,\r\n      code: error.code,\r\n      type: error.type,\r\n      stack: error.stack,\r\n      // Additional properties that might be useful\r\n      name: error.name,\r\n      cause: error.cause,\r\n    };\r\n  }\r\n\r\n  return errorResponse;\r\n}\r\n\r\n/**\r\n * Sends a formatted error response\r\n * \r\n * @param res The Vercel response object\r\n * @param error The error to format and send\r\n * @param statusCode The HTTP status code to use (default: 500)\r\n * @param includeDetails Whether to include detailed error information (default: false)\r\n */\r\nexport function sendApiError(\r\n  res: VercelResponse,\r\n  error: any,\r\n  statusCode = 500,\r\n  includeDetails = false\r\n): void {\r\n  // Log the error for server-side debugging\r\n  console.error(`API Error (${statusCode}):`, error);\r\n  \r\n  // Send the formatted error response\r\n  res.status(statusCode).json(formatApiError(error, includeDetails));\r\n}\r\n\r\n/**\r\n * Returns common error status codes based on error types\r\n * \r\n * @param error The error to analyze\r\n * @returns An appropriate HTTP status code\r\n */\r\nexport function getErrorStatusCode(error: any): number {\r\n  // Authentication errors\r\n  if (\r\n    error.type === 'StripeAuthenticationError' ||\r\n    error.message?.toLowerCase().includes('authentication') ||\r\n    error.message?.toLowerCase().includes('api key') ||\r\n    error.code === 'auth_error'\r\n  ) {\r\n    return 401;\r\n  }\r\n\r\n  // Validation errors\r\n  if (\r\n    error.type === 'StripeInvalidRequestError' || \r\n    error.message?.toLowerCase().includes('validation') ||\r\n    error.message?.toLowerCase().includes('invalid')\r\n  ) {\r\n    return 400;\r\n  }\r\n\r\n  // Resource not found\r\n  if (\r\n    error.type === 'StripeInvalidRequestError' && \r\n    error.message?.toLowerCase().includes('no such') ||\r\n    error.code === 'resource_missing'\r\n  ) {\r\n    return 404;\r\n  }\r\n\r\n  // Rate limiting errors\r\n  if (\r\n    error.type === 'StripeRateLimitError' ||\r\n    error.code === 'rate_limit_exceeded'\r\n  ) {\r\n    return 429;\r\n  }\r\n\r\n  // External service errors\r\n  if (\r\n    error.type === 'StripeAPIError' ||\r\n    error.type === 'StripeConnectionError'\r\n  ) {\r\n    return 502;\r\n  }\r\n\r\n  // Default to internal server error\r\n  return 500;\r\n}\r\n\r\n/**\r\n * Wrapper for API handler functions to catch and format errors consistently\r\n * \r\n * @param handler The API handler function to wrap\r\n * @returns A wrapped handler function with error handling\r\n */\r\nexport function withErrorHandling(\r\n  handler: (req: any, res: any) => Promise<any>\r\n) {\r\n  return async (req: any, res: any) => {\r\n    try {\r\n      return await handler(req, res);\r\n    } catch (error: any) {\r\n      const statusCode = getErrorStatusCode(error);\r\n      sendApiError(res, error, statusCode);\r\n    }\r\n  };\r\n}"],
  "mappings": "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",
  "names": ["Stripe", "handler"]
}
