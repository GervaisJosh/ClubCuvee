{
  "version": 3,
  "sources": ["membership-tiers.ts", "utils/stripeClient.ts", "../lib/supabaseAdmin.ts", "utils/errorHandler.ts"],
  "sourcesContent": ["import type { VercelRequest, VercelResponse } from '@vercel/node';\r\nimport { stripe } from './utils/stripeClient';\r\nimport { supabaseAdmin } from '../lib/supabaseAdmin';\r\nimport { withErrorHandling } from './utils/errorHandler';\r\n\r\nconst handler = async (req: VercelRequest, res: VercelResponse) => {\r\n  // Only allow POST (create) and PUT (update) requests\r\n  if (req.method !== 'POST' && req.method !== 'PUT') {\r\n    return res.status(405).json({ error: 'Method not allowed' });\r\n  }\r\n\r\n  try {\r\n    const {\r\n      id,               // Optional: If updating an existing tier\r\n      name,             // Required: Tier name\r\n      price,            // Required: Monthly price\r\n      description,      // Optional: Tier description\r\n      restaurant_id,    // Required: ID of the parent restaurant\r\n    } = req.body;\r\n\r\n    // Validate required fields\r\n    if (!name || !price || !restaurant_id) {\r\n      return res.status(400).json({ \r\n        error: 'Missing required fields: name, price, and restaurant_id are required' \r\n      });\r\n    }\r\n\r\n    // Validate price format\r\n    const priceNumber = parseFloat(price);\r\n    if (isNaN(priceNumber) || priceNumber <= 0) {\r\n      return res.status(400).json({\r\n        error: 'Price must be a positive number'\r\n      });\r\n    }\r\n\r\n    // Get restaurant info for product metadata/description\r\n    const { data: restaurant, error: restaurantError } = await supabaseAdmin\r\n      .from('restaurants')\r\n      .select('name')\r\n      .eq('id', restaurant_id)\r\n      .single();\r\n\r\n    if (restaurantError) {\r\n      console.error('Error fetching restaurant:', restaurantError);\r\n      return res.status(404).json({ \r\n        error: `Restaurant not found: ${restaurantError.message}` \r\n      });\r\n    }\r\n\r\n    // If restaurant doesn't exist, return error\r\n    if (!restaurant) {\r\n      return res.status(404).json({ \r\n        error: `Restaurant with ID ${restaurant_id} not found` \r\n      });\r\n    }\r\n\r\n    // Prepare tier data for database\r\n    const tierData = {\r\n      name,\r\n      price: priceNumber.toString(), // Store as string in database\r\n      description: description || '',\r\n      restaurant_id,\r\n      updated_at: new Date().toISOString()\r\n    };\r\n\r\n    let tier: any;\r\n    let existingTier: any = null;\r\n\r\n    // UPDATE FLOW: If ID is provided, update an existing tier\r\n    if (id) {\r\n      // First fetch the existing tier\r\n      const { data: fetchedTier, error: fetchError } = await supabaseAdmin\r\n        .from('membership_tiers')\r\n        .select('*')\r\n        .eq('id', id)\r\n        .eq('restaurant_id', restaurant_id) // Security check\r\n        .single();\r\n        \r\n      if (fetchError) {\r\n        return res.status(404).json({ \r\n          error: `Tier not found: ${fetchError.message}` \r\n        });\r\n      }\r\n      \r\n      existingTier = fetchedTier;\r\n      \r\n      // Update the tier in Supabase\r\n      const { data: updatedTier, error: updateError } = await supabaseAdmin\r\n        .from('membership_tiers')\r\n        .update(tierData)\r\n        .eq('id', id)\r\n        .select()\r\n        .single();\r\n      \r\n      if (updateError) {\r\n        return res.status(500).json({ \r\n          error: `Failed to update tier: ${updateError.message}` \r\n        });\r\n      }\r\n      \r\n      tier = updatedTier;\r\n    } \r\n    // CREATE FLOW: Insert a new tier\r\n    else {\r\n      // Create a new tier in Supabase\r\n      const { data: newTier, error: insertError } = await supabaseAdmin\r\n        .from('membership_tiers')\r\n        .insert([{\r\n          ...tierData,\r\n          created_at: new Date().toISOString()\r\n        }])\r\n        .select()\r\n        .single();\r\n      \r\n      if (insertError) {\r\n        return res.status(500).json({ \r\n          error: `Failed to create tier: ${insertError.message}` \r\n        });\r\n      }\r\n      \r\n      tier = newTier;\r\n    }\r\n\r\n    // STRIPE INTEGRATION LOGIC\r\n    try {\r\n      // Case 1: Tier already has Stripe IDs\r\n      if (existingTier && existingTier.stripe_product_id && existingTier.stripe_price_id) {\r\n        // Check if we need to update Stripe product\r\n        const hasNameChanged = existingTier.name !== name;\r\n        const hasDescriptionChanged = existingTier.description !== description;\r\n        \r\n        if (hasNameChanged || hasDescriptionChanged) {\r\n          // Update the product details in Stripe\r\n          await stripe.products.update(existingTier.stripe_product_id, {\r\n            name: `${restaurant.name} - ${name}`,\r\n            description: description || `${name} membership tier`\r\n          });\r\n        }\r\n        \r\n        // Check if price has changed\r\n        const hasPriceChanged = parseFloat(existingTier.price) !== priceNumber;\r\n        \r\n        if (hasPriceChanged) {\r\n          // Stripe doesn't allow updating prices, so we create a new one\r\n          // and mark the old one as inactive\r\n          \r\n          // 1. Archive the old price (don't delete it for history)\r\n          await stripe.prices.update(existingTier.stripe_price_id, {\r\n            active: false\r\n          });\r\n          \r\n          // 2. Create new price\r\n          const newPrice = await stripe.prices.create({\r\n            product: existingTier.stripe_product_id,\r\n            unit_amount: Math.round(priceNumber * 100), // Convert to cents\r\n            currency: 'usd',\r\n            recurring: { interval: 'month' },\r\n            metadata: {\r\n              restaurant_id,\r\n              tier_id: tier.id\r\n            }\r\n          });\r\n          \r\n          // 3. Update the tier with the new price ID\r\n          const { error: priceUpdateError } = await supabaseAdmin\r\n            .from('membership_tiers')\r\n            .update({ \r\n              stripe_price_id: newPrice.id,\r\n              updated_at: new Date().toISOString()\r\n            })\r\n            .eq('id', tier.id);\r\n            \r\n          if (priceUpdateError) {\r\n            console.error('Error updating tier with new price ID:', priceUpdateError);\r\n          }\r\n          \r\n          // Update our return object\r\n          tier.stripe_price_id = newPrice.id;\r\n        }\r\n      }\r\n      // Case 2: Tier needs new Stripe product and price\r\n      else {\r\n        // Create a product in Stripe\r\n        const product = await stripe.products.create({\r\n          name: `${restaurant.name} - ${name}`,\r\n          description: description || `${name} membership tier`,\r\n          metadata: {\r\n            tier_id: tier.id,\r\n            restaurant_id\r\n          }\r\n        });\r\n\r\n        // Create a price for the product\r\n        const price = await stripe.prices.create({\r\n          product: product.id,\r\n          unit_amount: Math.round(priceNumber * 100), // Convert to cents\r\n          currency: 'usd',\r\n          recurring: { interval: 'month' },\r\n          metadata: {\r\n            tier_id: tier.id,\r\n            restaurant_id\r\n          }\r\n        });\r\n\r\n        // Update the tier with the Stripe IDs\r\n        const { data: updatedTier, error: updateError } = await supabaseAdmin\r\n          .from('membership_tiers')\r\n          .update({ \r\n            stripe_product_id: product.id,\r\n            stripe_price_id: price.id,\r\n            updated_at: new Date().toISOString()\r\n          })\r\n          .eq('id', tier.id)\r\n          .select()\r\n          .single();\r\n          \r\n        if (updateError) {\r\n          console.error('Error updating tier with Stripe IDs:', updateError);\r\n        } else {\r\n          // Update our return object\r\n          tier = updatedTier;\r\n        }\r\n      }\r\n    } catch (stripeError: any) {\r\n      console.error('Stripe integration error:', stripeError);\r\n      \r\n      // Don't fail the request, but include the error in the response\r\n      return res.status(200).json({\r\n        tier,\r\n        warning: `Tier saved but Stripe integration failed: ${stripeError.message}`\r\n      });\r\n    }\r\n\r\n    // Return the tier with stripe_price_id & stripe_product_id\r\n    return res.status(200).json(tier);\r\n  } catch (error: any) {\r\n    console.error('Error processing membership tier:', error);\r\n    return res.status(500).json({ \r\n      error: 'Internal server error',\r\n      message: error.message \r\n    });\r\n  }\r\n}\r\n\r\n// Export with error handling wrapper\r\nexport default withErrorHandling(handler);", "import Stripe from 'stripe';\r\nimport { handleStripeError } from '@/lib/utils/errorHandler';\r\n\r\nconst stripeSecretKey = process.env.STRIPE_SECRET_KEY;\r\nif (!stripeSecretKey) {\r\n  console.error('STRIPE_SECRET_KEY is not configured in environment variables');\r\n}\r\n\r\nexport const stripe = new Stripe(stripeSecretKey || 'invalid_key', {\r\n  apiVersion: '2025-02-24.acacia',\r\n  maxNetworkRetries: 3,\r\n  typescript: true,\r\n  appInfo: {\r\n    name: 'Club Cuvee',\r\n    version: '1.0.0'\r\n  }\r\n});\r\n\r\n// Wrapper for Stripe API calls with error handling\r\nexport const stripeApi = {\r\n  createCheckoutSession: async (data: Stripe.Checkout.SessionCreateParams) => {\r\n    try {\r\n      const idempotencyKey = crypto.randomUUID();\r\n      return await stripe.checkout.sessions.create(data, {\r\n        idempotencyKey\r\n      });\r\n    } catch (error) {\r\n      throw handleStripeError(error);\r\n    }\r\n  },\r\n\r\n  createCustomer: async (data: Stripe.CustomerCreateParams) => {\r\n    try {\r\n      const idempotencyKey = crypto.randomUUID();\r\n      return await stripe.customers.create(data, {\r\n        idempotencyKey\r\n      });\r\n    } catch (error) {\r\n      throw handleStripeError(error);\r\n    }\r\n  },\r\n\r\n  createSubscription: async (data: Stripe.SubscriptionCreateParams) => {\r\n    try {\r\n      const idempotencyKey = crypto.randomUUID();\r\n      return await stripe.subscriptions.create(data, {\r\n        idempotencyKey\r\n      });\r\n    } catch (error) {\r\n      throw handleStripeError(error);\r\n    }\r\n  },\r\n\r\n  constructEvent: async (payload: string | Buffer, signature: string, secret: string) => {\r\n    try {\r\n      return stripe.webhooks.constructEvent(payload, signature, secret);\r\n    } catch (error) {\r\n      throw handleStripeError(error);\r\n    }\r\n  }\r\n};", "import { createClient } from '@supabase/supabase-js';\n\n// Initialize Supabase with service role key for admin operations\nexport const supabaseAdmin = createClient(\n  process.env.SUPABASE_URL as string,\n  process.env.SUPABASE_SERVICE_ROLE_KEY as string,\n  {\n    auth: {\n      autoRefreshToken: false,\n      persistSession: false\n    }\n  }\n); ", "import type { VercelResponse } from '@vercel/node';\r\nimport { ZodError } from 'zod';\r\n\r\nexport interface ApiErrorResponse {\r\n  status: 'error';\r\n  error: string;\r\n  code?: number;\r\n  type?: string;\r\n  details?: any;\r\n  deployment_url?: string;\r\n  errorDetails?: any;\r\n}\r\n\r\nexport class AppError extends Error {\r\n  constructor(\r\n    public statusCode: number,\r\n    message: string,\r\n    public isOperational = true\r\n  ) {\r\n    super(message);\r\n    Object.setPrototypeOf(this, AppError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Formats an error into a consistent API error response\r\n * \r\n * @param error The error object to format\r\n * @param includeDetails Whether to include detailed error information (default: false)\r\n * @returns A structured API error response object\r\n */\r\nexport function formatApiError(error: any, includeDetails = false): ApiErrorResponse {\r\n  // Extract common error properties\r\n  const errorResponse: ApiErrorResponse = {\r\n    status: 'error',\r\n    error: error.message || 'Internal server error',\r\n  };\r\n\r\n  // Add error type if available\r\n  if (error.type) {\r\n    errorResponse.type = error.type;\r\n  }\r\n\r\n  // Add error code if available\r\n  if (error.code || error.statusCode) {\r\n    errorResponse.code = error.code || error.statusCode;\r\n  }\r\n\r\n  // Include deployment context to help with debugging\r\n  const deployUrl = process.env.VERCEL_URL || process.env.FRONTEND_URL;\r\n  if (deployUrl) {\r\n    errorResponse.deployment_url = deployUrl.startsWith('http') ? deployUrl : `https://${deployUrl}`;\r\n  }\r\n\r\n  // Include detailed error information in development mode\r\n  if (includeDetails || process.env.NODE_ENV === 'development') {\r\n    errorResponse.errorDetails = {\r\n      message: error.message,\r\n      code: error.code,\r\n      type: error.type,\r\n      stack: error.stack,\r\n      // Additional properties that might be useful\r\n      name: error.name,\r\n      cause: error.cause,\r\n    };\r\n  }\r\n\r\n  return errorResponse;\r\n}\r\n\r\n/**\r\n * Sends a formatted error response\r\n * \r\n * @param res The Vercel response object\r\n * @param error The error to format and send\r\n * @param statusCode The HTTP status code to use (default: 500)\r\n * @param includeDetails Whether to include detailed error information (default: false)\r\n */\r\nexport function sendApiError(\r\n  res: VercelResponse,\r\n  error: any,\r\n  statusCode = 500,\r\n  includeDetails = false\r\n): void {\r\n  // Log the error for server-side debugging\r\n  console.error(`API Error (${statusCode}):`, error);\r\n  \r\n  // Send the formatted error response\r\n  res.status(statusCode).json(formatApiError(error, includeDetails));\r\n}\r\n\r\n/**\r\n * Returns common error status codes based on error types\r\n * \r\n * @param error The error to analyze\r\n * @returns An appropriate HTTP status code\r\n */\r\nexport function getErrorStatusCode(error: any): number {\r\n  // Authentication errors\r\n  if (\r\n    error.type === 'StripeAuthenticationError' ||\r\n    error.message?.toLowerCase().includes('authentication') ||\r\n    error.message?.toLowerCase().includes('api key') ||\r\n    error.code === 'auth_error'\r\n  ) {\r\n    return 401;\r\n  }\r\n\r\n  // Validation errors\r\n  if (\r\n    error.type === 'StripeInvalidRequestError' || \r\n    error.message?.toLowerCase().includes('validation') ||\r\n    error.message?.toLowerCase().includes('invalid')\r\n  ) {\r\n    return 400;\r\n  }\r\n\r\n  // Resource not found\r\n  if (\r\n    error.type === 'StripeInvalidRequestError' && \r\n    error.message?.toLowerCase().includes('no such') ||\r\n    error.code === 'resource_missing'\r\n  ) {\r\n    return 404;\r\n  }\r\n\r\n  // Rate limiting errors\r\n  if (\r\n    error.type === 'StripeRateLimitError' ||\r\n    error.code === 'rate_limit_exceeded'\r\n  ) {\r\n    return 429;\r\n  }\r\n\r\n  // External service errors\r\n  if (\r\n    error.type === 'StripeAPIError' ||\r\n    error.type === 'StripeConnectionError'\r\n  ) {\r\n    return 502;\r\n  }\r\n\r\n  // Default to internal server error\r\n  return 500;\r\n}\r\n\r\n/**\r\n * Wrapper for API handler functions to catch and format errors consistently\r\n * \r\n * @param handler The API handler function to wrap\r\n * @returns A wrapped handler function with error handling\r\n */\r\nexport function withErrorHandling(\r\n  handler: (req: any, res: any) => Promise<any>\r\n) {\r\n  return async (req: any, res: any) => {\r\n    try {\r\n      return await handler(req, res);\r\n    } catch (error: any) {\r\n      const statusCode = getErrorStatusCode(error);\r\n      sendApiError(res, error, statusCode);\r\n    }\r\n  };\r\n}\r\n\r\nexport const sendErrorResponse = (\r\n  res: VercelResponse,\r\n  error: Error | AppError | ZodError,\r\n  statusCode = 500\r\n) => {\r\n  // Set CORS headers\r\n  res.setHeader('Access-Control-Allow-Origin', '*');\r\n  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\r\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\r\n\r\n  // Handle preflight requests\r\n  if (res.req?.method === 'OPTIONS') {\r\n    return res.status(204).end();\r\n  }\r\n\r\n  // Handle Zod validation errors\r\n  if (error instanceof ZodError) {\r\n    return res.status(400).json({\r\n      error: 'Validation Error',\r\n      details: error.errors.map(err => ({\r\n        path: err.path.join('.'),\r\n        message: err.message\r\n      }))\r\n    });\r\n  }\r\n\r\n  // Handle operational errors (expected errors)\r\n  if (error instanceof AppError && error.isOperational) {\r\n    return res.status(error.statusCode).json({\r\n      error: error.message\r\n    });\r\n  }\r\n\r\n  // Handle unexpected errors\r\n  console.error('Unexpected error:', error);\r\n  return res.status(statusCode).json({\r\n    error: process.env.NODE_ENV === 'production' \r\n      ? 'An unexpected error occurred' \r\n      : error.message\r\n  });\r\n};\r\n\r\nexport const handleStripeError = (error: any) => {\r\n  if (error.type?.startsWith('Stripe')) {\r\n    throw new AppError(400, error.message);\r\n  }\r\n  throw error;\r\n};"],
  "mappings": "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",
  "names": ["Stripe", "handler", "price"]
}
